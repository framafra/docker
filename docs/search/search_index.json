{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Curso de Docker \u00b6","title":"Curso de Docker"},{"location":"#curso-de-docker","text":"","title":"Curso de Docker"},{"location":"almacenamiento/asociacion_bind_mount/","text":"Bind mounts \u00b6 Si elegimos conseguir la persistencia de los datos de los contenedores usando bind mount lo que estamos haciendo es \"mapear\" (montar) una parte de mi sistema de ficheros, de la que yo normalmente tengo el control, con una parte del sistema de ficheros del contenedor. Es decir, tipo de persistencia consiste en \u201cmontar\u201d un fichero o directorio de la m\u00e1quina anfitri\u00f3n en un fichero o directorio del contenedor. Este montaje se hace en el momento de crear el contenedor mediante dos par\u00e1metros distintos: \u201c-v\u201d que es m\u00e1s simple y \u201c--mount\u201d que es m\u00e1s expl\u00edcito. Con esto conseguimos: Compartir ficheros entre el host y los containers. Que otras aplicaciones que no sean docker tengan acceso a esos ficheros, ya sean c\u00f3digo, ficheros etc... Cosas a tener en cuenta: El fichero o directorio se indica en ambos casos con una ruta absoluta no tiene porque existir en el contenedor (si no existe, se crear\u00e1). El rendimiento de este tipo de persistencia, a efectos pr\u00e1cticos, depende del sistema de ficheros y caracter\u00edsticas hardware de la m\u00e1quina real. Una buena configuraci\u00f3n seg\u00fan las necesidades del contenedor influir\u00e1 en el rendimiento. Estos vol\u00famenes pueden ser usados por varios contenedores simult\u00e1neamente. En sistemas Linux no suele haber diferencias de rendimiento respecto a vol\u00famenes, pero en sistemas Windows y Mac el rendimiento es peor. Ejemplo: montando directorios usando bind mount \u00b6 En este caso vamos a crear un directorio en el sistema de archivo del host, donde vamos a crear un fichero index.html : $ mkdir web $ cd web /web$ echo \"<h1>Montando un bind mount</h1>\" > index.html Y podemos montar ese directorio en un contenedor, en este caso usamos la opci\u00f3n -v : $ docker run -d --name apa -v /home/usuario/web:/usr/local/apache2/htdocs -p 8080 :80 httpd:2.4 8de025f6ff4d4b8a5a57d10a9cbb283b103209f358c43148a4716a33a404e208 Y comprobamos que realmente estamos sirviendo el fichero que tenemos en el directorio que hemos creado. $ curl http://localhost:8080 <h1>Hola</h1> Eliminamos el contenedor y volvemos a crear otro con el directorio montado: $ docker rm -f apa apa $ docker run -d --name apa1 -v /home/usuario/web:/usr/local/apache2/htdocs -p 8080 :80 httpd:2.4 1751b04b0548217d7faa628fd69c10e84c695b0e5cc33b482df2c04a6af83292 $ curl http://localhost:8080 <h1>Hola</h1> Adem\u00e1s podemos comprobar que podemos modificar el contenido del fichero aunque este montado en el contenedor: $ echo \"<h1>Adios</h1>\" > web/index.html $ curl http://localhost:8080 <h1>Adios</h1> Por \u00faltimo, indicar que si nuestra carpeta origen no existe y hacemos un bind mount con -v , esa carpeta se crear\u00e1 pero lo que tendremos en el contenedor es una carpeta vac\u00eda. Pra m\u00e1s informaci\u00f3n sobre \"bind mount\" puedes consultar: https://docs.docker.com/storage/bind-mounts/","title":"Bind Mount"},{"location":"almacenamiento/asociacion_volumen/","text":"Vol\u00famenes docker \u00b6 Si elegimos conseguir la persistencia de datos usando vol\u00famenes estamos haciendo que los datos de los contenedores que nosotros decidamos se almacenen en una parte del sistema de ficheros que es gestionada por docker y a la que, debido a sus permisos, s\u00f3lo docker tendr\u00e1 acceso. En linux se guardan en /var/lib/docker/volumes . Este tipo de vol\u00famenes se suele usar en los siguiente casos: Para compartir datos entre contenedores. Simplemente tendr\u00e1n que usar el mismo volumen. Para copias de seguridad ya sea para que sean usadas posteriormente por otros contenedores o para mover esos vol\u00famenes a otros hosts. Cuando quiero almacenar los datos de mi contenedor no localmente si no en un proveedor cloud. Gestionando vol\u00famenes \u00b6 Los vol\u00famenes se pueden crear sin necesidad de asociarlo a un contenenos. Esto lo podemos hacer con el comando docker volume . Algunos comando \u00fatiles para trabajar con vol\u00famenes docker: docker volumen create mivolumen : Crea un volumen con el nombre \"mivolumnen\" vac\u00edo. docker volume rm mivolumen : Elimina el volumen \"mivolumen\", siempre que todo contenedor que lo utilice est\u00e9 parado. docker volumen prune : Para eliminar los vol\u00famenes que no est\u00e1n siendo usados por ning\u00fan contenedor. docker volume ls : Nos proporciona una lista de los vol\u00famenes creados y algo de informaci\u00f3n adicional. docker volume inspect : Nos dar\u00e1 una informaci\u00f3n mucho m\u00e1s detallada de el volumen que hayamos elegido. Una vez creado el volumen lo podemos asociar a cualquier contenedor con el flag --volume o -v . Si usamos im\u00e1genes de DockerHub, debemos leer la informaci\u00f3n que cada imagen nos proporciona en su p\u00e1gina ya que esa informaci\u00f3n suele indicar c\u00f3mo persistir los datos de esa imagen, ya sea con vol\u00famenes o bind mounts, y cu\u00e1les son las carpetas importantes en caso de ser im\u00e1genes que contengan ciertos servicios (web, base de datos etc...) Ejemplo usando vol\u00famenes docker \u00b6 Lo primero que vamos a hacer es crear un volumen docker: $ docker volume create mivol mivol A continuaci\u00f3n creamos un contenedor con el volumen asociado, usando --mount , y creamos un fichero index.html : $ docker run -d --name apa -v mivol:/usr/local/apache2/htdocs -p 81 :80 httpd:2.4 b51f89eb21701362279489c5b52a06b1a44c10194c00291de895b404ab347b80 $ docker exec apa bash -c 'echo \"<h1>Volumen de prueba</h1>\" > /usr/local/apache2/htdocs/index.html' Accedemos a un navegador y probamos la web http://localhost:81 Borramos el contenedor. $ docker rm -f apa apa Despu\u00e9s de borrar el contenedor, volvemos a crear otro contenedor con el mismo volumen asociado: $ docker run -d --name apa1 -v mivol:/usr/local/apache2/htdocs -p 82 :80 httpd:2.4 baa3511ca2227e30d90fa2b4b225e209889be4badff583ce58ac1feaa73d5d77 Y podemos comprobar en un navegador web http://localhost:82 que no se ha perdido la informaci\u00f3n (el fichero index.html ): Algunas aclaraciones: Al no indicar el volumen, se crear\u00e1 un nuevo volumen. Si usamos el flag -v e indicamos un nombre, se crear\u00e1 un volumen docker nuevo. Al usar tanto vol\u00famenes como bind mount, el contenido de lo que tenemos sobreescribir\u00e1 la carpeta destino en el sistema de ficheros del contenedor en caso de que exista. Para m\u00e1s informaci\u00f3n sobre volumenes puedes consultar https://docs.docker.com/storage/volumes/","title":"Vol\u00famenes"},{"location":"almacenamiento/volumenes/","text":"Los contenedores son ef\u00edmeros \u00b6 Por defecto, todos los archivos que se crean dentro de un contenedor se almacenan en la \u00faltima capa del sistema de archivos (la capa de lectura/escritura), esto quiere decir que los datos que tenemos en esta capa se perder\u00e1n cuando el contenedor se elimine y no podremos compartirlos con otros contenedores. Es decir, los contenedores son ef\u00edmeros , puesto que, los ficheros, datos y configuraciones que creamos en los contenedores sobreviven a las paradas de los mismos pero, sin embargo, son destruidos si el contenedor es destruido. Los datos en los contenedores \u00b6 Ante la situaci\u00f3n anteriormente descrita Docker nos proporciona varias soluciones para persistir los datos de los contenedores: Los vol\u00famenes docker . Los bind mount Los tmpfs mounts : Almacenan en memoria la informaci\u00f3n. (No lo vamos a ver)","title":"Tipos de almacenamiento"},{"location":"contenedores/arrancar_parar/","text":"Para arrancar/parar un contenedor ya creado (recordamos, docker run crea y arranca), existen los comandos docker start, docker stop y docker restart . La forma m\u00e1s habitual de usar estos comandos, es usar el nombre del comando, seguido del identificador \u00fanico o nombre asignado al contenedor. Por ejemplo con identificador: $docker start 434d318b3771 o con nombre del contenedor: $docker start NombreContenedor01 Cuidado Si cerramos el terminal, Docker continuar\u00e1 en funcionamiento.","title":"Arrancar/Parar Contenedores"},{"location":"contenedores/copiar/","text":"El comando docker cp es un comando que nos permite copiar ficheros y directorios del anfitri\u00f3n a un contenedor o viceversa. No se permite actualmente la copia de ficheros entre contenedores. COPIA CONTENEDOR \u2192 ANFITRI\u00d3N Copiando el fichero f1.txt que se encuentra en la carpeta /tmp del contenedor con identificador o nombre \u201cidcontainer\u201d al directorio actual de la m\u00e1quina que ejerce como anfitri\u00f3n. $docker cp idcontainer:/tmp/f1.txt ./ COPIA ANFITRI\u00d3N \u2192 CONTENEDOR Copiando el fichero f2.txt del directorio actual al directorio /tmp del contenedor. $docker cp ./f2.txt idcontainer:/tmp","title":"Copiar ficheros entre anfitri\u00f3n y contenedores"},{"location":"contenedores/dockerun/","text":"\u00bfQu\u00e9 hace el comando docker run? \u00b6 Es posiblemente el comando m\u00e1s utilizado. Podr\u00edamos decir que este comando crea un contenedor a partir de una imagen y lo arranca. Cuidado! Un error com\u00fan es creer que \u201cdocker run\u201d solo arranca contenedores. Si haces varios \u201cdocker run\u201d, est\u00e1s creando varios contenedores, no arrancando varias veces un contenedor. La sintaxis ser\u00eda la siguiente: $docker run -opciones NombreImagenContenedor [Comando al arrancar] [Argumentos] Esta opci\u00f3n crea el contenedor con las caracter\u00edsticas dadas en opciones, que pueden ser: -name Asigna un nombre al contenedor. -i Indica que el proceso lanzado en el contenedor docker estar\u00e1 en modo interactivo, es decir, enlaza la entrada est\u00e1ndar cuando se asigna un proceso a una terminal. -t Asigna al proceso lanzado al arrancar el contenedor una pseudo terminal, facilitando el acceso al mismo desde nuestra terminal.. -d Ejecuta el contenedor en modo \u201cbackground\u201d y nos muestra el ID. -a Asocia \u201cstandard input\u201d o \u201coutput\u201d a la sesi\u00f3n abierta. -cpus decimal \u2013 N\u00famero de CPUs asignadas. -IP asigna una IP. -mac-address string \u2013 Asigna una MAC address especial al contenedor. -mv Fija un l\u00edmite de memoria per este contenedor. -p Publica los puertos del contenedor en la red asignada. -rm Al parar el contenedor, se eliminar\u00e1 autom\u00e1ticamente. -tmpfs Monta un directorio en modo tmpfs (temporal, no tiene persistencia). -v Monta un directorio en el contenedor con persistencia, puede ser una carpeta del equipo real o un volumen Docker. -e Permite crear variable de entorno. Ejemplo Vamos arrancar un contenedor utilizando la imagen de Ubuntu 18.04, en modo interactivo, con nombre \u201cubu18\u201d, al mismo tiempo se nos abrir\u00e1 un terminal de bash para interactuar. Para ello ejecutaremos: docker run --name ubu18 -it ubuntu:18.04 /bin/bash Crear contenedores sin arrancarlos: docker run vs docker create El comando \u201cdocker run\u201d crea y arranca un contenedor. Si queremos crear un contenedor sin arrancarlo debemos utilizar el comando \u201cdocker create\u201d. La descripci\u00f3n completa del comando \u201cdocker create\u201d la pod\u00e9is encontrar en https://docs.docker.com/engine/reference/commandline/create/","title":"Crear Contenedores - Docker Run"},{"location":"contenedores/ejecutar_comando/","text":"El comando docker exec nos permite ejecutar un comando dentro de un contenedor que est\u00e9 en ese momento en ejecuci\u00f3n.\u00e7 La forma sintaxis habitual para utilizar este comando es: docker exec [OPCIONES] IDENTIFICADOR/NOMBRE COMANDO [ARGUMENTOS] Algunos ejemplos de uso, suponiendo un contenedor en marcha llamando \u201ccontenedor\u201d: Ejemplo 1 Se ejecuta en \u201cbackground\u201d, gracias al par\u00e1metro \u201c-d\u201d, y crea mediante el comando \u201ctouch\u201d un fichero \u201cprueba\u201d en \u201c/tmp\u201d. docker exec -d contenedor touch /tmp/prueba Ejemplo 2 Ejecuta la \u201cshell\u201d bash en nuestra consola (gracias al par\u00e1metro \u201c-it\u201d se enlaza la entrada y salida est\u00e1ndar a nuestra terminal). A efectos pr\u00e1cticos, con esta orden accederemos a una \u201cshell\u201d bash dentro del contenedor. docker exec -it contenedor bash Ejemplo 3 Comando que establece un variable de entorno con el par\u00e1metro \u201c-e\u201d. Se enlaza la entrada y salida de la ejecuci\u00f3n del comando con \u201c-it\u201d. A efectos pr\u00e1cticos, en esa \u201cshell\u201d estar\u00e1 disponible la variable de entorno \u201cVAR1\u201d con valor 1. Lo podemos probar con docker exec -it echo $VAR1 docker exec -it -e VAR=1 contenedor bash La descripci\u00f3n completa del comando \u201cdocker exec\u201d la pod\u00e9is encontrar en https://docs.docker.com/engine/reference/commandline/exec/","title":"Ejecutar comandos"},{"location":"contenedores/eliminar/","text":"Hay diferentes formas de eliminar contenedores dependiendo de c\u00f3mo lo queramos hacer: Si vamos a eliminar un contenedor que est\u00e1 parado previamente. $docker rm IDENTIFICADOR/NOMBRE Si queremos parar todos los contenedores que tenemos y borrarlos, hay que realizar dos pasos: \u2013 Paramos los contenedores (opcional). $docker stop $(docker ps -a -q) \u2013 Borramos todos los contenedores. $docker rm $(docker ps -a -q)","title":"Eliminar contenedores"},{"location":"contenedores/inspect/","text":"El comando docker inspect es un comando que nos proporciona diversos detalles de la configuraci\u00f3n de un contenedor. Ofrece distintos datos, entre ellos, identificador \u00fanico (versi\u00f3n 64 caracteres), almacenamiento, red, imagen en que se basa, etc. Su sintaxis es: docker inspect IDENTIFICADOR/NOMBRE La descripci\u00f3n completa del comando docker inspect la pod\u00e9is encontrar en https://docs.docker.com/engine/reference/commandline/inspect/","title":"Inspeccionar Contenedores"},{"location":"contenedores/listar/","text":"Mediante el comando docker ps podemos listar los contenedores en el sistema,tanto parados como en ejecuci\u00f3n. Si ejecutamos solo docker ps nos indica los que est\u00e1n en ejecuci\u00f3n $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 02e86fdf39bd httpd \"httpd-foreground\" About a minute ago Up About a minute 0 .0.0.0:8080->80/tcp, :::8080->80/tcp my-apache-app Mientras si ejecutamos lo siguiente: $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 02e86fdf39bd httpd \"httpd-foreground\" 8 minutes ago Up 8 minutes 0 .0.0.0:8080->80/tcp, :::8080->80/tcp my-apache-app db20a19fbd04 ubuntu \"bash\" 9 minutes ago Exited ( 0 ) 9 minutes ago contenedor1 0f7c3e9e6690 ubuntu \"echo 'Hello world'\" 9 minutes ago Exited ( 0 ) 9 minutes ago lucid_goldwasser La informaci\u00f3n que obtenemos de los contenedores es la siguiente: CONTAINER_ID : identificador \u00fanico del contenedor. IMAGE : imagen utilizada para crear el contenedor. COMMAND : comando que se lanza al arrancar el contenedor. CREATED : cuando se cre\u00f3 el contenedor. STATUS : si el contenedor est\u00e1 en marcha o no (indicando cu\u00e1nto lleva en marcha o cu\u00e1nto hace que se par\u00f3). PORTS : redirecci\u00f3n de puertos del contenedor. NAMES : nombre del contenedor. Se puede generar como par\u00e1metro al crear el contenedor, o si no se indica nada, el propio Docker genera un nombre aleatorio.","title":"Listar Contenedores"},{"location":"contenedores/renombrar/","text":"El comando docker rename nos permite cambiar el nombre asociado a un contenedor. $docker rename NombreContenedor NuevoNombreContenedor Cambia el nombre de NombreContenedor a NuevoNombreContenedor.","title":"Renombrar Contenedores"},{"location":"contenedores/ejemplos/demonio/","text":"En esta ocasi\u00f3n hemos utilizado la opci\u00f3n -d del comando run , para que la ejecuci\u00f3n del comando en el contenedor se haga en segundo plano. $ docker run -d --name contenedor2 ubuntu bash -c \"while true; do echo hello world; sleep 1; done\" 7b6c3b1c0d650445b35a1107ac54610b65a03eda7e4b730ae33bf240982bba08 NOTA: En la instrucci\u00f3n docker run hemos ejecutado el comando con bash -c que nos permite ejecutar uno o mas comandos en el contenedor de forma m\u00e1s compleja (por ejemplo, indicando ficheros dentro del contenedor). Comprueba que el contenedor se est\u00e1 ejecutando Comprueba lo que est\u00e1 haciendo el contenedor ( docker logs contenedor2 ) Por \u00faltimo podemos parar el contenedor y borrarlo con las siguientes instrucciones: $ docker stop contenedor2 $ docker rm contenedor2 Hay que tener en cuenta que un contenedor que esta ejecut\u00e1ndose no puede ser eliminado. Tendr\u00edamos que para el contenedor y posteriormente borrarlo. Otra opci\u00f3n es borrarlo a la fuerza: $ docker rm -f contenedor2","title":"Creando un contenedor demonio"},{"location":"contenedores/ejemplos/interactivo/","text":"En este caso usamos la opci\u00f3n -i para abrir una sesi\u00f3n interactiva, -t nos permite crear un pseudo-terminal que nos va a permitir interaccionar con el contenedor, indicamos un nombre del contenedor con la opci\u00f3n --name , y la imagen que vamos a utilizar para crearlo, en este caso ubuntu , y por \u00faltimo el comando que vamos a ejecutar, en este caso bash , que lanzar\u00e1 una sesi\u00f3n bash en el contenedor: $ docker run -it --name contenedor1 ubuntu bash root@2bfa404bace0:/# El contenedor se para cuando salimos de \u00e9l. Para volver a conectarnos a \u00e9l: $ docker start contenedor1 contenedor1 $ docker attach contenedor1 root@2bfa404bace0:/# Si el contenedor se est\u00e1 ejecutando podemos ejecutar comandos en \u00e9l con el subcomando exec : $ docker start contenedor1 contenedor1 $ docker exec contenedor1 ls -al Con la orden docker restart reiniciamos el contenedor, lo paramos y lo iniciamos. Para mostrar informaci\u00f3n de un contenedor ejecutamos docker inspect : $ docker inspect contenedor1 [ { \"Id\" : \"178871769ac2fcbc1c73ce378066af01436b52a15894685b7321088468a25db7\" , \"Created\" : \"2021-01-28T19:12:21.764255155Z\" , \"Path\" : \"bash\" , \"Args\" : [] , \"State\" : { \"Status\" : \"exited\" , \"Running\" : false, \"Paused\" : false, ... Nos muestra mucha informaci\u00f3n, est\u00e1 en formato JSON (JavaScript Object Notation) y nos da datos sobre aspectos como: El id del contenedor. Los puertos abiertos y sus redirecciones Los bind mounts y vol\u00famenes usados. El tama\u00f1o del contenedor La configuraci\u00f3n de red del contenedor. El ENTRYPOINT que es lo que se ejecuta al hacer docker run. El valor de las variables de entorno. Y muchas m\u00e1s cosas.... En realidad, todas las im\u00e1genes tienen definidas un proceso que se ejecuta, en concreto la imagen ubuntu tiene definida por defecto el proceso bash , por lo que podr\u00edamos haber ejecutado: $ docker run -it --name contenedor1 ubuntu","title":"Ejecuci\u00f3n de un contenedor interactivo"},{"location":"contenedores/ejemplos/simple/","text":"Vamos a comprobar que todo funciona creando nuestro primer contenedor desde la imagen hello-world : $ docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 0e03bdcc26d7: Pull complete Digest: sha256:31b9c7d48790f0d8c50ab433d9c3b7e17666d6993084c002c2ff1ca09b96391d Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1 . The Docker client contacted the Docker daemon. 2 . The Docker daemon pulled the \"hello-world\" image from the Docker Hub. ( amd64 ) 3 . The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4 . The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Pero, \u00bfqu\u00e9 es lo que est\u00e1 sucediendo al ejecutar esa orden?: Al ser la primera vez que ejecuto un contenedor basado en esa imagen, la imagen hello-word se descarga desde el repositorio que se encuentra en el registro que vayamos a utilizar, en nuestro caso DockerHub. Muestra el mensaje de bienvenida que es la consecuencia de ejecutar un comando al crear y arrancar un contenedor basado en esa imagen. Si listamos los contenedores que se est\u00e1n ejecutando ( docker ps ): $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Comprobamos que este contenedor no se est\u00e1 ejecutando. Un contenedor ejecuta un proceso y cuando termina la ejecuci\u00f3n, el contenedor se para. Para ver los contenedores que no se est\u00e1n ejecutando: $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 372ca4634d53 hello-world \"/hello\" 8 minutes ago Exited ( 0 ) 8 minutes ago elastic_johnson Para eliminar el contenedor podemos identificarlo con su id : $ docker rm 372ca4634d53 o con su nombre: $ docker rm elastic_johnson","title":"Ejecuci\u00f3n de un contenedor simple"},{"location":"contenedores/ejemplos/variables/","text":"Es posible que necesitemos crear un contenedor que necesita alguna configuraci\u00f3n espec\u00edfica, lo que vamos a hacer es crear variables de entorno en el contenedor, para que el proceso que inicializa el contenedor pueda realizar dicha configuraci\u00f3n. Para crear una variable de entorno al crear un contenedor usamos el flag -e o --env : $ docker run -it --name prueba -e USUARIO = prueba ubuntu bash root@91e81200c633:/# echo $USUARIO prueba Configuraci\u00f3n de un contenedor con la imagen mariadb \u00b6 En ocasiones es obligatorio el inicializar alguna variable de entorno para que el contenedor pueda ser ejecutado. Si miramos la documentaci\u00f3n en Docker Hub de la imagen mariadb, observamos que podemos definir algunas variables de entorno para la creaci\u00f3n y configuraci\u00f3n del contenedor (por ejemplo: MYSQL_DATABASE , MYSQL_USER , MYSQL_PASSWORD ,...). Pero hay una que la tenemos que indicar de forma obligatoria, la contrase\u00f1a del usuario root ( MYSQL_ROOT_PASSWORD ), por lo tanto: $ docker run -d --name some-mariadb -e MYSQL_ROOT_PASSWORD = my-secret-pw mariadb $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9c3effd891e3 mariadb \"docker-entrypoint.s\u2026\" 8 seconds ago Up 7 seconds 3306 /tcp some-mariadb Podemos ver que se ha creado una variable de entorno: $ docker exec -it some-mariadb env ... MYSQL_ROOT_PASSWORD = my-secret-pw ... Y para acceder podemos ejecutar: $ docker exec -it some-mariadb bash root@9c3effd891e3:/# mysql -u root -p \" $MYSQL_ROOT_PASSWORD \" ... MariaDB [( none )] > Otra forma de hacerlo ser\u00eda: $ docker exec -it some-mariadb mysql -u root -p Enter password: ... MariaDB [( none )] > Accediendo a servidor de base de datos desde el exterior \u00b6 En el ejemplo anterior hemos accedido a la base de datos de dos formas: Ejecutado un comando bash para acceder al contenedor y desde dentro hemos utilizado el cliente de mariadb para acceder a la base de datos. Ejecutando directamente en el contenedor el cliente de mariadb. En esta ocasi\u00f3n vamos a mapear los puertos para acceder desde el exterior a la base de datos: Lo primero que vamos a hacer es eliminar el contenedor anterior: $ docker rm -f some-mariadb Y a continuaci\u00f3n vamos a crear otro contenedor, pero en esta ocasi\u00f3n vamos a mapear el puerto 3306 del anfitri\u00f3n con el puerto 3306 del contenedor: docker run -d -p 3306 :3306 --name some-mariadb -e MYSQL_ROOT_PASSWORD = my-secret-pw mariadb Comprobamos que los puertos se han mapeado y que el contenedor est\u00e1 ejecut\u00e1ndose: $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 816ea7df5c41 mariadb \"docker-entrypoint.s\u2026\" 3 seconds ago Up 2 seconds 0 .0.0.0:3306->3306/tcp some-mariadb Ahora desde nuestro equipo (donde hemos instalado un cliente de mysql) nos conectamos que tiene la ip 192.168.121.54 vamos a conectarnos a la base de datos (hay que tener instalado el cliente de mariadb): $ mysql -u root -p -h 192 .168.121.54 Enter password: ... MariaDB [( none )] > Tambi\u00e9n nos podemos conectar usando la direcci\u00f3n 127.0.0.1 : $ mysql -u root -p -h 127 .0.0.1 Enter password: ... MariaDB [( none )] >","title":"Configuraci\u00f3n de contenedores con variables de entorno"},{"location":"contenedores/ejemplos/web/","text":"Tenemos muchas im\u00e1genes en el registro p\u00fablico docker hub , por ejemplo podemos crear un servidor web con apache 2.4: $ docker run -d --name my-apache-app -p 8080 :80 httpd:2.4 Vemos que el contenedor se est\u00e1 ejecutando, adem\u00e1s con la opci\u00f3n -p mapeamos un puerto del equipo donde tenemos instalado el docker, con un puerto del contenedor: Si accedemos a la ip del ordenador que tiene instalado docker al primer puerto indicado, se redigira la petici\u00f3n a la ip del contenedor al segundo puerto indicado. Nunca utilizamos directamente la ip del contenedor para acceder a \u00e9l . Para probarlo accede desde un navegador a la ip del servidor con docker (en mi caso: 192.168.121.54 y al puerto 8080 : Para acceder al log del contenedor podemos ejecutar: $ docker logs my-apache-app Con la opci\u00f3n logs -f seguimos visualizando los logs en tiempo real. Modificaci\u00f3n del contenido servidor por el servidor web \u00b6 Si consultamos la documentaci\u00f3n de la imagen httpd en el registro docker Hub, podemos determinar que le servidor web que se ejecuta en el contenedor guardar sus ficheros (directorio DocumentRoot ) en /usr/local/apache2/htdocs/ . Vamos a crear un nu nuevo fichero index.html en ese directorio. Lo podemos hacer de varias formas: Accediendo de forma interactiva al contenedor y haciendo la modificaci\u00f3n: $ docker exec -it my-apache-app bash root@cf3cd01a4993:/usr/local/apache2# cd /usr/local/apache2/htdocs/ root@cf3cd01a4993:/usr/local/apache2/htdocs# echo \"<h1>Curso Docker</h1>\" > index.html root@cf3cd01a4993:/usr/local/apache2/htdocs# exit Ejecutando directamente el comando de creaci\u00f3n del fichero index.html en el contenedor: $ docker exec my-apache-app bash -c 'echo \"<h1>Curso Docker</h1>\" > /usr/local/apache2/htdocs/index.html' Independientemente de c\u00f3mo hayamos creado el fichero, podemos volver a acceder al servidor web y comprobar que efectivamente hemos cambiado el contenido del index.html :","title":"Creando un contenedor con un servidor web"},{"location":"docker/docker/","text":"\u00bfQu\u00e9 es Docker? \u00b6 \"Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales.\" 1 Docker es un proyecto de c\u00f3digo abierto. Generalmente dispone de varias versiones: Docker CE (Community Edition) : el motor de Docker, de c\u00f3digo abierto.. Docker EE (Enterprise Edition): lo mismo que la versi\u00f3n CE, solo que adem\u00e1s incluye certificaci\u00f3n de funcionamiento en algunos sistemas concretos y soporte con la empresa Docker Inc. P\u00e1gina Oficial Docker Wikipedia \u21a9","title":"\u00bfQu\u00e9 es Docker?"},{"location":"docker/docker/#que-es-docker","text":"\"Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales.\" 1 Docker es un proyecto de c\u00f3digo abierto. Generalmente dispone de varias versiones: Docker CE (Community Edition) : el motor de Docker, de c\u00f3digo abierto.. Docker EE (Enterprise Edition): lo mismo que la versi\u00f3n CE, solo que adem\u00e1s incluye certificaci\u00f3n de funcionamiento en algunos sistemas concretos y soporte con la empresa Docker Inc. P\u00e1gina Oficial Docker Wikipedia \u21a9","title":"\u00bfQu\u00e9 es Docker?"},{"location":"docker/imagenvscontenedor/","text":"Es importante aclarar algunos conceptos sobre qu\u00e9 son im\u00e1genes y contenedores y cuales son sus caracter\u00edsticas de estos: Im\u00e1genes La imagen es una plantilla de solo lectura que se utiliza para crear contenedores. A partir de una imagen pueden crearse m\u00faltiples contenedores Las im\u00e1genes, adem\u00e1s de tener sus sistema de ficheros predefinido, tienen una serie de par\u00e1metros predefinidos (comandos, de variables de entorno, etc.) con valores por defecto y que se pueden personalizar en el momento de crear el contenedor. Docker permite crear nuevas im\u00e1genes bas\u00e1ndose en im\u00e1genes anteriores. Se podr\u00eda decir que una imagen puede estar formada por un conjunto de \u201ccapas\u201d que han modificado una imagen base. Al crear una nueva imagen, simplemente estamos a\u00f1adiendo una capa a la imagen anterior, la que act\u00faa como base. Contenedores Son instancias de una imagen. Pueden ser arrancados, parados y ejecutados. Cada contenedor Docker posee un identificador \u00fanico de 64 caracteres, pero habitualmente se utiliza una versi\u00f3n corta con los primeros 12 caracteres. Tambi\u00e9n se les puede dar un nombre. S\u00edmil Un s\u00edmil para entender estos conceptos: una instalaci\u00f3n de una distribuci\u00f3n de Linux mediante un DVD. Ese DVD ser\u00eda nuestra imagen y el sistema operativo instalado ser\u00eda el contenedor.","title":"\u00bfQu\u00e9 es una imagen y un contenedor?"},{"location":"docker_compose/almacenamiento/","text":"Adem\u00e1s de definir los services , con docker-compose podemos definir los vol\u00famenes que vamos a necesitar en nuestra infraestructura. Adem\u00e1s, como hemos visto, podremos indicar que vol\u00famen va a utilizar cada contenedor. Veamos un ejemplo: version : '3.1' services : db : container_name : contenedor_mariadb image : mariadb restart : always environment : MYSQL_ROOT_PASSWORD : asdasd volumes : - mariadb_data:/var/lib/mysql volumes : mariadb_data : Y podemos iniciar el escenario: $ docker-compose up -d Creating network \"docker-compose_default\" with the default driver Creating volume \"docker-compose_mariadb_data\" with default driver Creating contenedor_mariadb ... done $ docker-compose ps Name Command State Ports ------------------------------------------------------------------- contenedor_mariadb docker-entrypoint.sh mysqld Up 3306 /tcp Y comprobamos que se ha creado un nuevo volumen: $ docker volume ls DRIVER VOLUME NAME local docker-compose_mariadb_data ... En la definici\u00f3n del servicio db hemos indicado que el contenedor montar\u00e1 el volumen en un directorio determinado con el par\u00e1metro volumes . Podemos comprobar que efectivamente se ha realizado el montaje: $ docker inspect contenedor_mariadb ... \"Mounts\" : [ { \"Type\" : \"volume\" , \"Name\" : \"docker-compose_mariadb_data\" , \"Source\" : \"/var/lib/docker/volumes/docker-compose_mariadb_data/_data\" , \"Destination\" : \"/var/lib/mysql\" , \"Driver\" : \"local\" , \"Mode\" : \"rw\" , \"RW\" : true, \"Propagation\" : \"\" } ] , ... Recuerda que si necesitas iniciar el escenario desde 0, debes eliminar el volumen: $ docker-compose down -v Stopping contenedor_mariadb ... done Removing contenedor_mariadb ... done Removing network docker-compose_default Removing volume docker-compose_mariadb_data Utilizaci\u00f3n de bind mount con docker-compose \u00b6 De forma similar podemos indicar que un contenedor va a utilizar bind mount como almacenamiento. En este caso ser\u00eda: version : '3.1' services : db : container_name : contenedor_mariadb image : mariadb restart : always environment : MYSQL_ROOT_PASSWORD : asdasd volumes : - ./data:/var/lib/mysql Y despu\u00e9s de iniciar el escenario podemos ver c\u00f3mo se ha creado el directorio data : $ cd data/ /data$ ls aria_log.00000001 aria_log_control ibdata1 ib_logfile0 ibtmp1 mysql","title":"Almacenamiento con docker-compose"},{"location":"docker_compose/comandos/","text":"Una vez hemos creado el archivo docker-compose.yml tenemos que empezar a trabajar con \u00e9l, es decir a crear los contenedores que describe su contenido. Esto lo haremos mediante el ejecutable docker-compose . Es importante destacar que debemos invocarla desde el directorio en el que se encuentra el fichero docker-compose.yml . Los subcomandos m\u00e1s usados son: docker-compose up : Crear los contenedores (servicios) que est\u00e1n descritos en el docker-compose.yml . docker-compose up -d : Crear los contenedores en modo detach (segundo plano) que est\u00e1n descritos en el docker-compose.yml . Eso significa que no muestran mensajes de log en el terminal y que se nos vuelve a mostrar un prompt. docker-compose stop : Detiene los contenedores que previamente se han lanzado con docker-compose up . docker-compose run : Inicia los contenedores descritos en el docker-compose.yml que est\u00e9n parados. docker-compose rm : Borra los contenedores parados del escenario. Con las opci\u00f3n -f elimina tambi\u00e9n los contenedores en ejecuci\u00f3n. docker-compose pause : Pausa los contenedores que previamente se han lanzado con docker-compose up . docker-compose unpause : Reanuda los contenedores que previamente se han pausado. docker-compose restart : Reinicia los contenedores. Orden ideal para reiniciar servicios con nuevas configuraciones. docker-compose down : Para los contenedores, los borra y tambi\u00e9n borra las redes que se han creado con docker-compose up (en caso de haberse creado). docker-compose down -v : Para los contenedores y borra contenedores, redes y vol\u00famenes. docker-compose logs : Muestra los logs de todos los servicios del escenario. Con el par\u00e1metro -f podremos ir viendo los logs en \"vivo\". docker-compose logs servicio1 : Muestra los logs del servicio llamado servicio1 que estaba descrito en el docker-compose.yml . docker-compose exec servicio1 /bin/bash : Ejecuta una orden, en este caso /bin/bash en un contenedor llamado servicio1 que estaba descrito en el docker-compose.yml docker-compose build : Ejecuta, si est\u00e1 indicado, el proceso de construcci\u00f3n de una imagen que va a ser usado en el docker-compose.yml a partir de los ficheros Dockerfile que se indican. docker-compose top : Muestra los procesos que est\u00e1n ejecut\u00e1ndose en cada uno de los contenedores de los servicios. Ejemplo de uso \u00b6 $ docker-compose up -d Creating network \"letschat_default\" with the default driver Creating mongo ... done Creating letschat ... done Podemos ver los contenedores que se est\u00e1n ejecutando: $ docker-compose ps Name Command State Ports ------------------------------------------------------------------------------- letschat npm start Up 5222 /tcp, 0 .0.0.0:80->8080/tcp mongo docker-entrypoint.sh mongod Up 27017 /tcp Finalmente podemos destruir el escenario: $ docker-compose down Stopping letschat ... done Stopping mongo ... done Removing letschat ... done Removing mongo ... done Removing network letschat_default","title":"Comandos docker-compose"},{"location":"docker_compose/dockercompose/","text":"Muchas veces necesitamos ejecutar varios contenedores para que nuestra aplicaci\u00f3n funcione (por ejemplo al desplegar una p\u00e1gina web din\u00e1mica, donde utilizamos un contenedor para la BBDD y otro para el servidor web). Es decir: Necesitamos varios servicios para que la aplicaci\u00f3n funcione: Partiendo del principio de que cada contenedor ejecuta un s\u00f3lo proceso, si necesitamos que la aplicaci\u00f3n use varios servicios (web, base de datos, proxy inverso, ...) cada uno de ellos se implementar\u00e1 en un contenedor. Si tenemos construida nuestra aplicaci\u00f3n con microservicios, cada uno de ellos se podr\u00e1 implementar en un contenedor independiente. Por tanto, el proceso de poner en marcha varios contenedores es tedioso, ya que usualmente debemos levantar \u201ca mano\u201d esos contenedores, respetando el orden de levantado, etc. Docker Compose es una herramienta para definir y ejecutar aplicaciones multi-contenedor. Con un solo comando podremos crear e iniciar todos los servicios que necesitamos para nuestra aplicaci\u00f3n. Los casos de uso m\u00e1s habituales para docker-compose son: Entornos de desarrollo Entornos de testeo autom\u00e1ticos (integraci\u00f3n cont\u00ednua) Despliegue en host individuales (no clusters) Compose tiene comandos para manejar todo el ciclo de vida de nuestra aplicaci\u00f3n: Iniciar, detener y rehacer servicios. Ver el estado de los servicios. Visualizar los logs. Ejecutar un comando en un servicio. Para utilizar Docker Compose, vamos a crear en un fichero llamado docker-compose.yaml , y en \u00e9l definiremos los contenedores y las caracter\u00edsticas de los mismo que deseamos utilizar. Posteriormente, mediante la utilidad docker-compose gestionaremos los contenedores. Ventajas de usar docker-compose \u00b6 Hacer todo de manera declarativa para que no tenga que repetir todo el proceso cada vez que construyo el escenario. Poner en funcionamiento todos los contenedores que necesita mi aplicaci\u00f3n de una sola vez y debidamente configurados. Garantizar que los contenedores se arrancan en el orden adecuado . Por ejemplo: mi aplicaci\u00f3n no podr\u00e1 funcionar debidamente hasta que no est\u00e9 el servidor de bases de datos funcionando en marcha. Asegurarnos de que hay comunicaci\u00f3n entre los contenedores que pertenecen a la aplicaci\u00f3n. M\u00e1s informaci\u00f3n en https://docs.docker.com/compose/","title":"\u00bfQu\u00e9 es Docker Compose?"},{"location":"docker_compose/ejemplo1/","text":"En este ejemplo vamos a desplegar con docker-compose la aplicaci\u00f3n guestbook . Puedes encontrar el fichero docker-compose.yml en en este directorio del repositorio. En el fichero docker-compose.yml vamos a definir el escenario. El programa docker-compose se debe ejecutar en el directorio donde este ese fichero. version : '3.1' services : app : container_name : guestbook image : iesgn/guestbook restart : always ports : - 80:5000 db : container_name : redis image : redis restart : always Para crear el escenario: $ docker-compose up -d Creating network \"guestbook_default\" with the default driver Creating guestbook ... done Creating redis ... done Para listar los contenedores: $ docker-compose ps Name Command State Ports ------------------------------------------------------------------------- guestbook python3 app.py Up 0 .0.0.0:80->5000/tcp redis docker-entrypoint.sh redis ... Up 6379 /tcp Para parar los contenedores: $ docker-compose stop Stopping guestbook ... done Stopping redis ... done Para eliminar el escenario: docker-compose down Stopping guestbook ... done Stopping redis ... done Removing guestbook ... done Removing redis ... done Removing network guestbook_default","title":"Ejemplo 1.- Despliegue aplicaci\u00f3n guestbook"},{"location":"docker_compose/ejemplo2/","text":"En este ejemplo vamos a desplegar con docker-compose la aplicaci\u00f3n Temperaturas . Puedes encontrar el fichero docker-compose.yml en en este directorio del repositorio. En este caso el fichero docker-compose.yml puede tener esta forma: version : '3.1' services : frontend : container_name : temperaturas-frontend image : iesgn/temperaturas_frontend restart : always ports : - 80:3000 depends_on : - backend backend : container_name : temperaturas-backend image : iesgn/temperaturas_backend restart : always Para crear el escenario: $ docker-compose up -d Creating network \"temperaturas_default\" with the default driver Creating temperaturas-backend ... done Creating temperaturas-frontend ... done Para listar los contenedores: $ docker-compose ps --------------------------------------------------------------------- temperaturas-backend python3 app.py Up 5000 /tcp temperaturas-frontend python3 app.py Up 0 .0.0.0:80->3000/tcp","title":"Ejemplo 2.- Despliegue de la aplicaci\u00f3n Temperaturas"},{"location":"docker_compose/ejemplo3/","text":"En este ejemplo vamos a desplegar con docker-compose la aplicaci\u00f3n WordPress + MariaDB. Puedes encontrar los ficheros docker-compose.yml en este directorio del repositorio. Utilizando vol\u00famenes docker \u00b6 Por ejemplo para la ejecuci\u00f3n de wordpress persistente con vol\u00famenes docker podr\u00edamos tener un fichero docker-compose.yml con el siguiente contenido: version : '3.1' services : wordpress : container_name : servidor_wp image : wordpress restart : always environment : WORDPRESS_DB_HOST : db WORDPRESS_DB_USER : user_wp WORDPRESS_DB_PASSWORD : asdasd WORDPRESS_DB_NAME : bd_wp ports : - 80:80 volumes : - wordpress_data:/var/www/html/wp-content db : container_name : servidor_mysql image : mariadb restart : always environment : MYSQL_DATABASE : bd_wp MYSQL_USER : user_wp MYSQL_PASSWORD : asdasd MYSQL_ROOT_PASSWORD : asdasd volumes : - mariadb_data:/var/lib/mysql volumes : wordpress_data : mariadb_data : Para crear el escenario: $ docker-compose up -d Creating network \"wp_default\" with the default driver Creating servidor_wp ... done Creating servidor_mysql ... done Para listar los contenedores: $ docker-compose ps Name Command tate Ports --------------------------------------------------------------------------- servidor_mysql docker-entrypoint.sh mysqld Up 306 /tcp servidor_wp docker-entrypoint.sh apach ... Up 0 .0.0.0:80->80/tcp Para parar los contenedores: $ docker-compose stop Stopping servidor_wp ... done Stopping servidor_mysql ... done Para borrar los contenedores: $ docker-compose rm Going to remove servidor_wp, servidor_mysql Are you sure? [ yN ] y Removing servidor_wp ... done Removing servidor_mysql ... done Para eliminar el escenario (contenedores, red y vol\u00famenes): $ docker-compose down -v Stopping servidor_mysql ... done Stopping servidor_wp ... done Removing servidor_mysql ... done Removing servidor_wp ... done Removing network volumen_default Removing volume volumen_wordpress_data Removing volume volumen_mariadb_data Utilizando bind-mount \u00b6 Por ejemplo para la ejecuci\u00f3n de wordpress persistente con bind mount podr\u00edamos tener un fichero docker-compose.yml con el siguiente contenido: version : '3.1' services : wordpress : container_name : servidor_wp image : wordpress restart : always environment : WORDPRESS_DB_HOST : db WORDPRESS_DB_USER : user_wp WORDPRESS_DB_PASSWORD : asdasd WORDPRESS_DB_NAME : bd_wp ports : - 80:80 volumes : - ./wordpress:/var/www/html/wp-content db : container_name : servidor_mysql image : mariadb restart : always environment : MYSQL_DATABASE : bd_wp MYSQL_USER : user_wp MYSQL_PASSWORD : asdasd MYSQL_ROOT_PASSWORD : asdasd volumes : - ./mysql:/var/lib/mysql","title":"Ejemplo 3.- Despliegue de WordPress + Mariadb"},{"location":"docker_compose/ejemplo4/","text":"En este \u00faltimo ejemplo vamos a construir una imagen de una aplicaci\u00f3n PHP que necesita conectarse a una base de datos mariadb para guardar o leer informaci\u00f3n. Por lo tanto, vamos a construir la imagen para que podamos indicar variables de entorno para configurar las credenciales de acceso a la base de datos. Puedes encontrar los ficheros en este directorio del repositorio. Aplicaci\u00f3n PHP \u00b6 Como ejemplo vamos a \"dockerizar\" una aplicaci\u00f3n PHP simple que accede a una tabla de una base de datos. La aplicaci\u00f3n la puedes encontrar en el directorio build/app/index.php . Algunas cosas que hay que tener en cuenta: Cuando programamos una aplicaci\u00f3n tenemos que tener en cuenta que va a ser implantada usando Docker tenemos que hacer algunas modificaciones, por ejemplo en este caso, las credenciales para el acceso a la base de datos la leemos de variables de entorno (que posteriormente ser\u00e1n creadas en el contenedor): <?php // Database host $host = getenv ( 'DB_HOST' ); // Database user name $user = getenv ( 'DB_USER' ); //Database user password $pass = getenv ( 'DB_PASS' ); //Database name $db = getenv ( 'DB_NAME' ); // check the MySQL connection status $conn = new mysqli ( $host , $user , $pass , $db ); if ( $conn -> connect_error ) { die ( \"Connection failed: \" . $conn -> connect_error ); } else { $sql = 'SELECT * FROM users' ; if ( $result = $conn -> query ( $sql )) { while ( $data = $result -> fetch_object ()) { $users [] = $data ; } } foreach ( $users as $user ) { echo \"<br>\" ; echo $user -> username . \" \" . $user -> password ; echo \"<br>\" ; } } mysqli_close ( $conn ); ?> En el fichero schema.sql encontramos las instrucciones sql necesarias para inicializar la base de datos. Configurar nuestra aplicaci\u00f3n con variables de entorno \u00b6 En los casos en que necesitamos modificar algo en la aplicaci\u00f3n o hacer alg\u00fan proceso en el momento de crear el contenedor, lo que hacemos es crear un script en bash que meteremos en la imagen y que ser\u00e1 la instrucci\u00f3n que indiquemos en el CMD . Este script en concreto har\u00e1 las siguiente operaciones: Utilizando el fichero schema.sql (que tambi\u00e9n guardaremos en la imagen) inicializar\u00e1 la base de datos. Ejecutar el servidor web en segundo plano. En el directorio de trabajo encontramos: build : Ser\u00e1 el contexto necesario para crear la imagen de la aplicaci\u00f3n. El fichero docker-compose.yml : Para crear el escenario. El contexto (directorio build) \u00b6 En el directorio de contexto tendremos tres ficheros: Fichero script.sh \u00b6 El fichero script.sh que se guardar\u00e1 en la imagen y se ejecutar\u00e1 con al iniciar el contenedor. Su contenido es el siguiente: #!/bin/bash while ! mysql -u ${ DB_USER } -p ${ DB_PASS } -h ${ DB_HOST } -e \";\" ; do sleep 1 done mysql -u ${ DB_USER } -p ${ DB_PASS } -h ${ DB_HOST } ${ DB_NAME } < /opt/schema.sql apache2ctl -D FOREGROUND Esperamos hasta que la base de datos est\u00e9 disponible, inicializamos la base de datos con el fichero schema.sql y finalmente iniciamos el servidor web. Fichero schema.sql \u00b6 Son las instrucciones sql que nos permiten crear la tabla necesaria en la base de datos. Fichero Dockerfile \u00b6 El fichero Dockerfile ser\u00eda el siguiente: FROM php:7.4-apache RUN apt-get update && apt-get install -y mariadb-client RUN docker-php-ext-install mysqli && docker-php-ext-enable mysqli ADD app /var/www/html/ EXPOSE 80 ENV DB_USER user1 ENV DB_PASS asdasd ENV DB_NAME usuarios ENV DB_HOST mariadb ADD script.sh /usr/local/bin/script.sh ADD schema.sql /opt RUN chmod +x /usr/local/bin/script.sh CMD [ \"/usr/local/bin/script.sh\" ] Algunas observaciones: Creamos la imagen desde una imagen PHP. Instalamos el cliente de mariadb que nos har\u00e1 falta para inicializar la base de datos desde nuestro contenedor de la aplicaci\u00f3n. Siguiendo la documentaci\u00f3n de la imagen oficial de PHP instalamos el m\u00f3dulo PHP mysqli . Copiamos la aplicaci\u00f3n en el servidor web. Creamos las variables de entorno y le damos valores por defecto, por si no se indican en la creaci\u00f3n del contenedor. Copiamos los ficheros del script y del esquema de la base de datos a la imagen. Y le damos permisos de ejecuci\u00f3n a script.sh . Finalmente indicamos con CMD el comando que se va a ejecutar al iniciar el contenedor. En este caso ejecutaremos el script. Creaci\u00f3n de la imagen \u00b6 Ejecutamos dentro del directorio de contexto: $ docker build -t josedom24/aplicacion_php . Despliegue de la aplicaci\u00f3n \u00b6 Usaremos el fichero docker-compose.yml : version : '3.1' services : app : container_name : contenedor_php image : josedom24/aplicacion_php restart : always environment : DB_HOST : servidor_mysql DB_USER : user1 DB_PASS : asdasd DB_NAME : usuarios ports : - 8080:80 depends_on : - db db : container_name : servidor_mysql image : mariadb restart : always environment : MYSQL_DATABASE : usuarios MYSQL_USER : user1 MYSQL_PASSWORD : asdasd MYSQL_ROOT_PASSWORD : asdasd volumes : - mariadb_data:/var/lib/mysql volumes : mariadb_data : Y ya podemos levantar el escenario, ejecutando: $ docker-compose up -d Y finalmente podemos acceder a la aplicaci\u00f3n y comprobar que funciona.","title":"Ejemplo 4.- Construcci\u00f3n de im\u00e1genes configurables con variables de entorno"},{"location":"docker_compose/fichero/","text":"El fichero \u201cdocker-compose.yml\u201d es un fichero en formato YAML que definir\u00e1 los contenedores que queremos crear y el comportamiento de los mismos. Lo habitual, es tener ese fichero en la ra\u00edz de nuestro proyecto. Formato YAML \u00b6 YAML es el acr\u00f3nimo recursivo de \u201cYAML Ain't Markup Language\u201d, que en castellano significa, \u201cYAML no es un lenguaje de marcas\u201d. M\u00e1s informaci\u00f3n en https://es.wikipedia.org/wiki/YAML YAML es a efectos pr\u00e1cticos una forma de definir informaci\u00f3n utilizando formato texto. Funciona de forma similar a XML o JSON. El uso de YAML dentro de \u201cDocker Compose\u201d es sencillo y f\u00e1cilmente entendible con cada uno de los ejemplos. Contenido del archivo 'docker-compose.yml' \u00b6 El contenido del archivo docker-compose.yml sigue unas especificaciones. La \u00faltima especificaci\u00f3n completa es la de la versi\u00f3n 3.9. Estas especificaciones est\u00e1n definicas en https://docs.docker.com/compose/compose-file/compose-file-v3/ Los par\u00e1metros m\u00e1s importantes de dicha especificaci\u00f3n de describen a continuaci\u00f3n: version .- Indica la versi\u00f3n de la especificaci\u00f3n del fichero \u201cdocker-compose.yml\u201d no es necesario ponerlo desde la versi\u00f3n 1.27.0 de \u201cDocker Compose\u201d. services .- Array asociativo con las diferentes plantillas de cada contenedor que queremos crear. build .- Sirve para contruir la imagen de un contenedor a partir de un \"Dockerfile\", la forma m\u00e1s habitual de usarla es indicar en qu\u00e9 directorio est\u00e1 nuestro nuestro \u201cDockerfile\u201d de la forma \u201cbuild: ./directorio\u201d. Para m\u00e1s detalles https://docs.docker.com/compose/compose-file/compose-file-v3/#build , command .- Sobreescribe el comando por defecto a la imagen. Se usa de la forma \u201ccommand: /bin/bash\u201d. container_name .- Especifica el nombre de contenedor (si no, se generar\u00e1 autom\u00e1ticamente). Se usa de la forma \u201ccontainer_name: micontenedor\u201d depends_on .- Indica que el contenedor de la plantilla depende de otro que se haya creado previamente, puesto que los contenedores se crean de forma secuencial a c\u00f3mo est\u00e1n declarados en el fichero docker-compose.yml. Del mismo modo los contenedores se detienen en orden inverso a c\u00f3mo se han declarado. Se puden ver ejemplos en https://docs.docker.com/compose/compose-file/compose-file-v3/#depends_on env_file y environment .- Permite definir variables de entorno en la plantilla del contenedor. env_file especifica un fichero o lista de ficheros donde est\u00e1n definidas las variables de entorno, similar a \u201cenv_file: .env\u201d environment especifica una lista de variables de entorno con su valor. Ejemplos en https://docs.docker.com/compose/compose-file/compose-file-v3/#environment expose / ports .- Permite definir un conjunto de puertos que estar\u00e1n abiertos en el contenedor. Ejemplos en https://docs.docker.com/compose/compose-file/compose-file-v3/#expose y en https://docs.docker.com/compose/compose-file/compose-file-v3/#ports . image .- Espec\u00edfica la imagen en la que se basa el contenedor. No es necesario cuando se especifica a partir de un \u201cDockerfile\u201d. network_mode : especifica el modo de red, de forma similar al par\u00e1metro --network de Docker. Los modos soportados se detallan en el siguiente enlace [https://docs.docker.com/compose/compose-file/compose-file-v3/#network_mode] (https://docs.docker.com/compose/compose-file/compose-file-v3/#network_mode) networks .- Define las redes a crear para poner en marcha nuestros contenedores. Ejemplos en https://docs.docker.com/compose/compose-file/compose-file-v3/#networks restart .- Indica cuando debe reiniciarse el contenedor. El valor por defecto es \u201cno\u201d (no se reinicia). Otros valores soportados son \u201calways\u201d (se reinicia cuando el contenedor se para) y \u201con-failure\u201d (se reinicia si el contenedor se para y devuelve un valor de salida distinto de cero) y \u201cunless-stoped\u201d (se reinicia siempre, excepto si el contenedor es parado manualmente con \u201cdocker stop\u201d). Ejemplos https://docs.docker.com/compose/compose-file/compose-file-v3/#restart volumes .- establece una lista de vol\u00famenes, ya sea en formato \u201cbind mount\u201d o volumen Docker. Si quieres reutilizar un volumen entre distintas plantillas, adem\u00e1s debes definir la variable \u201cvolumes\u201d fuera de las plantillas de contenedores. Ejemplos https://docs.docker.com/compose/compose-file/compose-file-v3/#volumes Ejemplo \u00b6 A continuaci\u00f3n se muestra un ejemplo de un fichero docker-compose.yml version: '3.8' services: app: container_name: letschat image: sdelements/lets-chat restart: always environment: LCB_DATABASE_URI: mongodb://mongo/letschat ports: - 80:8080 depends_on: - db db: container_name: mongo image: mongo restart: always volumes: - /opt/mongo:/data/db","title":"Fichero docker-compose.yml"},{"location":"docker_compose/instalacion/","text":"La manera m\u00e1s sencilla de realizar la instalaci\u00f3n de esta herramienta es utilizar el paquete de nuestra distribuci\u00f3n: apt install docker-compose Tambi\u00e9n se puede con pip en un entorno virtual: python3 -m venv docker-compose source docker-compose/bin/activate ( docker-compose ) ~# pip install docker-compose Puedes acceder a la documentaci\u00f3n oficial para ver otras posibilidades de instalaci\u00f3n.","title":"Instalaci\u00f3n de Docker Compose"},{"location":"dockerfile/buenas_practicas/","text":"Los contenedores deber ser \"ef\u00edmeros\" : Cuando decimos \"ef\u00edmeros\" queremos decir que la creaci\u00f3n, parada, despliegue de los contenedores creados a partir de la imagen que vamos a generar con nuestro Dockerfile debe tener una m\u00ednima configuraci\u00f3n. Uso de ficheros .dockerignore : Como hemos indicado anteriormente, todos los ficheros del contexto se env\u00edan al docker engine , es recomendable usar un directorio vac\u00edo donde vamos creando los ficheros que vamos a enviar. Adem\u00e1s, para aumentar el rendimiento, y no enviar al daemon ficheros innecesarios podemos hacer uso de un fichero .dockerignore , para excluir ficheros y directorios. No instalar paquetes innecesarios : Para reducir la complejidad, dependencias, tiempo de creaci\u00f3n y tama\u00f1o de la imagen resultante, se debe evitar instalar paquetes extras o innecesarios. Si alg\u00fan paquete no es necesario durante la creaci\u00f3n de la imagen, lo mejor es desinstalarlo durante el proceso. Minimizar el n\u00famero de capas : Debemos encontrar el balance entre la legibilidad del Dockerfile y minimizar el n\u00famero de capa que utiliza. Indicar las instrucciones a ejecutar en m\u00faltiples l\u00edneas : Cada vez que sea posible y para hacer m\u00e1s f\u00e1cil futuros cambios, hay que organizar los argumentos de las instrucciones que contengan m\u00faltiples l\u00edneas, esto evitar\u00e1 la duplicaci\u00f3n de paquetes y har\u00e1 que el archivo sea m\u00e1s f\u00e1cil de leer. Por ejemplo: RUN apt-get update && apt-get install -y \\ git \\ wget \\ apache2 \\ php5","title":"Buenas pr\u00e1cticas al crear Dockerfile"},{"location":"dockerfile/dockerbuild/","text":"El comando docker build construye la nueva imagen leyendo las instrucciones del fichero Dockerfile y la informaci\u00f3n de un entorno , que para nosotros va a ser un directorio (aunque tambi\u00e9n podemos guardar informaci\u00f3n, por ejemplo, en un repositorio git). La creaci\u00f3n de la imagen es ejecutada por el docker engine , que recibe toda la informaci\u00f3n del entorno, por lo tanto es recomendable guardar el Dockerfile en un directorio vac\u00edo y a\u00f1adir los ficheros necesarios para la creaci\u00f3n de la imagen. El comando docker build ejecuta las instrucciones de un Dockerfile l\u00ednea por l\u00ednea y va mostrando los resultados en pantalla. Tenemos que tener en cuenta que cada instrucci\u00f3n ejecutada crea una imagen intermedia, una vez finalizada la construcci\u00f3n de la imagen nos devuelve su id. Algunas im\u00e1genes intermedias se guardan en cach\u00e9 , otras se borran. Por lo tanto, si por ejemplo, en un comando ejecutamos cd /scripts/ y en otra linea le mandamos a ejecutar un script ( ./install.sh ) no va a funcionar, ya que ha lanzado otra imagen intermedia. Teniendo esto en cuenta, la manera correcta de hacerlo ser\u00eda: cd /scripts/ ; ./install.sh Para terminar indicar que la creaci\u00f3n de im\u00e1genes intermedias generadas por la ejecuci\u00f3n de cada instrucci\u00f3n del Dockerfile , es un mecanismo de cach\u00e9, es decir, si en alg\u00fan momento falla la creaci\u00f3n de la imagen, al corregir el Dockerfile y volver a construir la imagen, los pasos que hab\u00edan funcionado anteriormente no se repiten ya que tenemos a nuestra disposici\u00f3n las im\u00e1genes intermedias, y el proceso contin\u00faa por la instrucci\u00f3n que caus\u00f3 el fallo. Ejemplo de Dockerfile \u00b6 Vamos a crear una imagen con ubuntu, al cu\u00e1l le vamos a instalar apache y vamos a poner una web (index.html) con nuestro nombre. Para ellos creamos un directorio en nuestro pc llamado miprimerdockerfile, en ese directorio colocaremos el fichero index.html y crearemos un fichero llamado Dockerfile El contenido de Dockerfile ser\u00e1: FROM ubuntu:latest MAINTAINER Paco Ma\u00f1o \"fj.manofrasquet@edu.gva.es\" RUN apt update && apt install -y apache2 COPY index.html /var/www/html/ CMD [ \"/usr/sbin/apache2ctl\" , \"-D\" , \"FOREGROUND\" ] Para crear la imagen uso el comando docker build , indicando el nombre de la nueva imagen (opci\u00f3n -t ) y indicando el directorio contexto. $ docker build -t framafra/ubuntuapache:v1 . Nota: Ponemos como directorio el . porque estamos ejecutando esta instrucci\u00f3n dentro del directorio donde est\u00e1 el Dockerfile . A la imagen que voy a crear la llamos framafra/ubuntuapache y le pongo el tag de v1 Una vez terminado, podr\u00edamos ver que hemos generado una nueva imagen: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE framafra/ubuntuapache v1 4816f9eee434 11 seconds ago 225MB ... Ahora podemos crear el contendor a partir de la imagen creada, ejecutando el siguiente comando: $ docker run -d -p 8080 :80 --name web_server framafra/ubuntuapache:v1","title":"Construyendo im\u00e1genes con docker build"},{"location":"dockerfile/ejemplo1/","text":"En este ejemplo vamos a crear una im\u00e1gen con una p\u00e1gina est\u00e1tica. Vamos a crear tres versiones de la imagen, y puedes encontrar los ficheros en este directorio del repositorio. Versi\u00f3n 1: Desde una imagen base \u00b6 Tenemos un directorio, que en Docker se denomina contexto, donde tenemos el fichero Dockerfile y un directorio, llamado index.html con nuestra p\u00e1gina web: $ ls Dockerfile index.hmtl En este caso vamos a usar una imagen base de un sistema operativo sin ning\u00fan servicio. El fichero Dockerfile ser\u00e1 el siguiente: FROM debian RUN apt-get update && apt-get install -y apache2 ADD index.html /var/www/html/ EXPOSE 80 CMD [ \"/usr/sbin/apache2ctl\" , \"-D\" , \"FOREGROUND\" ] Al usar una imagen base debian tenemos que instalar los paquetes necesarios para tener el servidor web, en este acaso apache2. A continuaci\u00f3n a\u00f1adiremos el contenido del directorio index.hmtl al directorio /var/www/html/ del contenedor y finalmente indicamos el comando que se deber\u00e1 ejecutar al crear un contenedor a partir de esta imagen: iniciamos el servidor web en segundo plano. Para crear la imagen ejecutamos: $ docker build -t framafra/apa:v1 . Comprobamos que la imagen se ha creado: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE framafra/apa v1 705eb816b4f3 1 minute ago 253MB Y podemos crear un contenedor: $ docker run -d -p 81 :80 --name webserver1 framafra/apa:v1 Y acceder con el navegador a nuestra p\u00e1gina: Versi\u00f3n 2: Desde una imagen con apache2 \u00b6 En este caso el fichero Dockerfile ser\u00eda el siguiente: FROM httpd:2.4 ADD index.html /usr/local/apache2/htdocs/ EXPOSE 80 En este caso no necesitamos instalar nada, ya que la imagen tiene instalado el servidor web. En este caso y siguiendo la documentaci\u00f3n de la imagen el DocumentRoot es /usr/local/apache2/htdocs/ . No es necesario indicar el CMD ya que por defecto el contenedor creado a partir de esta imagen ejecutar\u00e1 el mismo proceso que la imagen base, es decir, la ejecuci\u00f3n del servidor web. De forma similar, crear\u00edamos una imagen y un contenedor: $ docker build -t framafra/apa:v2 . $ docker run -d -p 82 :80 --name webserver2 framafra/apa:v2 Versi\u00f3n 3: Desde una imagen con nginx \u00b6 En este caso el fichero Dockerfile ser\u00eda: FROM nginx ADD index.hmtl /usr/share/nginx/html EXPOSE 80 De forma similar, crear\u00edamos una imagen y un contenedor: $ docker build -t framafra/ngx:v1 . $ docker run -d -p 83 :80 --name webserver3 framafra/ngx:v1","title":"Ejemplo 1.- Construcci\u00f3n de im\u00e1genes con una p\u00e1gina est\u00e1tica"},{"location":"dockerfile/ejemplo2/","text":"En este ejemplo vamos a crear una im\u00e1gen con una p\u00e1gina desarrollada con PHP. Vamos a crear dos versiones de la imagen, y puedes encontrar los ficheros en este directorio del repositorio. Versi\u00f3n 1: Desde una imagen base \u00b6 En el contexto vamos a tener el fichero Dockerfile y un directorio, llamado app con nuestra aplicaci\u00f3n. En este caso vamos a usar una imagen base de un sistema operativo sin ning\u00fan servicio. El fichero Dockerfile ser\u00e1 el siguiente: FROM debian RUN apt-get update && apt-get install -y apache2 libapache2-mod-php7.4 php7.4 && apt-get clean && rm -rf /var/lib/apt/lists/* ADD app /var/www/html/ RUN rm /var/www/html/index.html EXPOSE 80 CMD [ \"/usr/sbin/apache2ctl\" , \"-D\" , \"FOREGROUND\" ] Al usar una imagen base debian tenemos que instalar los paquetes necesarios para tener el servidor web, php y las librerias necesarias.A continuaci\u00f3n a\u00f1adiremos el contenido del directorio app al directorio /var/www/html/ del contenedor. Borramos el fichero /var/www/html/index.html para que no sea el que se muestre por defecto y finalmente indicamos el comando que se deber\u00e1 ejecutar al crear un contenedor a partir de esta imagen e iniciamos el servidor web en segundo plano. Para crear la imagen ejecutamos: $ docker build -t framafra/ejemplo2:latest . Comprobamos que la imagen se ha creado: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE framafra/ejemplo2 latest 8c3275799063 1 minute ago 226MB Y podemos crear un contenedor: $ docker run -d -p 80 :80 --name ejemplo2 framafra/ejemplo2 Y acceder con el navegador a nuestra p\u00e1gina: La aplicaci\u00f3n tiene un fichero info.php que me da informaci\u00f3n sobre PHP, en este caso observamos que estamos usando la versi\u00f3n 7.3: Versi\u00f3n 2: Desde una imagen con PHP instalado \u00b6 En este caso el fichero Dockerfile ser\u00eda el siguiente: FROM php:7.4-apache ADD app /var/www/html/ EXPOSE 80 En este caso no necesitamos instalar nada, ya que la imagen tiene instalado el servidor web y PHP. No es necesario indicar el CMD ya que por defecto el contenedor creado a partir de esta imagen ejecutar\u00e1 el mismo proceso que la imagen base, es decir, la ejecuci\u00f3n del servidor web. De forma similar, crear\u00edamos una imagen y un contenedor: $ docker build -t josedom24/ejemplo2:v2 . $ docker run -d -p 80 :80 --name ejemplo2 josedom24/ejemplo2:v2 Podemos acceder al fichero info.php para comprobar la versi\u00f3n de php que estamos utilizando con esta imagen:","title":"Ejemplo 2.- Construcci\u00f3n de im\u00e1genes con una una aplicaci\u00f3n PHP"},{"location":"dockerfile/ejemplo3/","text":"En este ejemplo vamos a construir una imagen para servir una aplicaci\u00f3n escrita en Python utilizando el framework flask. La aplicaci\u00f3n ser\u00e1 servida en el puerto 3000/tcp. Puedes encontrar los ficheros en este directorio del repositorio. En el contexto vamos a tener el fichero Dockerfile y un directorio, llamado app con nuestra aplicaci\u00f3n. En este caso vamos a usar una imagen base de un sistema operativo sin ning\u00fan servicio. El fichero Dockerfile ser\u00e1 el siguiente: FROM debian RUN apt-get update && apt-get install -y python3-pip && apt-get clean && rm -rf /var/lib/apt/lists/* COPY app /usr/share/app WORKDIR /usr/share/app RUN pip3 install --no-cache-dir -r requirements.txt EXPOSE 3000 CMD [ \"python3\" , \"app.py\" ] Algunas consideraciones: S\u00f3lo tenemos que instalar pip, que utilizaremos posteriormente para instalar los paquetes Python. Copiamos nuestra aplicaci\u00f3n en cualquier directorio. Con WORKDIR nos posicionamos en el directorio indicado. Todas las instrucciones posteriores se realizar\u00e1n sobre ese directorio. Instalamos los paquetes python con pip, que est\u00e1n listados en el fichero requirements.txt . El proceso que se va a ejecutar por defecto al iniciar el contenedor ser\u00e1 python3 app.py que arranca un servidor web en el puerto 3000/tcp ofreciendo la aplicaci\u00f3n. Para crear la imagen ejecutamos: $ docker build -t josedom24/ejemplo3:v1 . Comprobamos que la imagen se ha creado: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE josedom24/ejemplo3 v1 8c3275799063 1 minute ago 226MB Y podemos crear un contenedor: $ docker run -d -p 80 :3000 --name ejemplo2 josedom24/ejemplo3:v1 Y acceder con el navegador a nuestra p\u00e1gina:","title":"Ejemplo 3.- Construcci\u00f3n de im\u00e1genes con una una aplicaci\u00f3n Python"},{"location":"dockerfile/file_dockerfile/","text":"Docker nos permite generar de forma autom\u00e1tica nuestras propias im\u00e1genes usando el comando \u201cdocker build\u201d y los ficheros llamados Dockerfile . Un fichero Dockerfile es un conjunto de instrucciones que ser\u00e1n ejecutadas de forma secuencial para construir una nueva imagen docker . Cada una de estas instrucciones crea una nueva capa en la imagen que estamos creando. Los ficheros Dockerfile pueden crearse con cualquier editor de texto, pero recomendamos el editor multiplataforma \u201cVisual Studio Code\u201d https://code.visualstudio.com/. Al instalarlo, si detecta Docker instalado en el sistema, el propio editor nos sugerir\u00e1 una serie de plugins que merece la pena instalarlos. En cualquier caso se pueden instalar posterioremente de forma manual, alguno de los m\u00e1s recomendados son: Docker y Dev Containers La estructura fundamental de un fichero Dockerfile suele ser la siguiente: Indicamos imagen base con la instrucci\u00f3n FROM A\u00f1adimos metadatos a la im\u00e1gen con la instrucci\u00f3n LABEL Instrucciones de construcci\u00f3n con instrucciones como RUN, COPY, ADD, WORKDIR. Configuraci\u00f3n: Variable de entornos, usuarios, puertos: USER, EXPOSE, ENV Instrucciones de arranque: CMD, ENTRYPOINT","title":"El fichero DockerFile"},{"location":"dockerfile/instrucciones/","text":"Alguna de las principales instrucciones son: FROM : Sirve para especificar la imagen sobre la que voy a construir la m\u00eda. Ejemplo: FROM php:7.4-apache . LABEL : Sirve para a\u00f1adir metadatos a la imagen mediante clave=valor. Ejemplo: LABEL company=iesjaumeII . COPY : Para copiar ficheros desde mi equipo a la imagen. Esos ficheros deben estar en el mismo contexto (carpeta o repositorio). Su sintaxis es COPY [--chown=<usuario>:<grupo>] src dest . Por ejemplo: COPY --chown=www-data:www-data myapp /var/www/html . ADD : Es similar a COPY pero tiene funcionalidades adicionales como especificar URLs y tratar archivos comprimidos. RUN : Ejecuta una orden creando una nueva capa. Su sintaxis es RUN orden / RUN [\"orden\",\"param1\",\"param2\"] . Ejemplo: RUN apt update && apt install -y git . En este caso es muy importante que pongamos la opci\u00f3n -y porque en el proceso de construcci\u00f3n no puede haber interacci\u00f3n con el usuario. WORKDIR : Establece el directorio de trabajo dentro de la imagen que estoy creando para posteriormente usar las \u00f3rdenes RUN,COPY,ADD,CMD o ENTRYPOINT. Ejemplo: WORKDIR /usr/local/apache/htdocs . EXPOSE : Nos da informaci\u00f3n acerca de qu\u00e9 puertos tendr\u00e1 abiertos el contenedor cuando se cree uno en base a la imagen que estamos creando. Es meramente informativo . Ejemplo: EXPOSE 80 . USER : Para especificar (por nombre o UID/GID) el usuario de trabajo para todas las \u00f3rdenes RUN,CMD Y ENTRYPOINT posteriores. Ejemplos: USER framafra / USER 1001:10001 . ARG : Para definir variables para las cuales los usuarios pueden especificar valores a la hora de hacer el proceso de build mediante el flag --build-arg . Su sintaxis es ARG nombre_variable o ARG nombre_variable=valor_por_defecto . Posteriormente esa variable se puede usar en el resto de la \u00f3rdenes de la siguiente manera $nombre_variable . Ejemplo: ARG usuario=www-data . No se puede usar con ENTRYPOINT Y CMD. ENV : Para establecer variables de entorno dentro del contenedor. Puede ser usado posteriormente en las \u00f3rdenes RUN a\u00f1adiendo $ delante de el nombre de la variable de entorno. Ejemplo: ENV WEB_DOCUMENT_ROOT=/var/www/html . No se puede usar con ENTRYPOINT Y CMD. ENTRYPOINT : Para establecer el ejecutable que se lanza siempre cuando se crea el contenedor con docker run , salvo que se especifique expresamente algo diferente con el flag --entrypoint . Su s\u00edntaxis es la siguiente: ENTRYPOINT <command> / ENTRYPOINT [\"executable\",\"param1\",\"param2\"] . Ejemplo: ENTRYPOINT [\"/usr/sbin/apache2ctl\",\"-D\",\"FOREGROUND\"] . CMD : Para establecer el ejecutable por defecto (salvo que se sobreescriba desde la orden docker run ) o para especificar par\u00e1metros para un ENTRYPOINT . Si tengo varios s\u00f3lo se ejecuta el \u00faltimo. Su sintaxis es CMD param1 param2 / CMD [\"param1\",\"param2\"] / CMD[\"command\",\"param1\"] . Ejemplo: CMD [\u201c-c\u201d \u201c/etc/nginx.conf\u201d] / ENTRYPOINT [\u201cnginx\u201d] . LABEL : permite establecer metadatos dentro de la imagen mediante etiquetas. Explicaci\u00f3n de algunas instrucciones \u00b6 EXPOSE \u00b6 En primer lugar, repasamos la diferencia entre exponer y publicar puertos en Docker: Si no se expone ni publica un puerto, este s\u00f3lo es accesible desde el interior del contenedor. Exponer un puerto, indica que ese puerto es accesible tanto dentro del propio contenedor como por otros contenedores, pero no desde fuera (incluido el anfitri\u00f3n). Publicar un puerto, indica que el puerto es accesible desde fuera del contenedor, por lo cual debe asociarse a un puerto del anfitri\u00f3n. La opci\u00f3n EXPOSE nos permite indicar los puertos por defecto expuestos que tendr\u00e1 un contenedor basado en esta imagen. Es similar a la opci\u00f3n \u201c--expose\u201d de \u201cdocker run\u201d (y de paso, recordamos que \u201cdocker run\u201d con \u201c-p\u201d los publica). Por ejemplo, para exponer 80 443 y 8080 indicaremos: EXPOSE 80 443 8080 ADD/COPY \u00b6 ADD y COPY son comandos para copiar ficheros de la m\u00e1quina anfitri\u00f3n al nuevo contenedor. Se recomienda usar COPY, excepto que queramos descomprimir un \u201czip\u201d, que ADD permite su descompresi\u00f3n. M\u00e1s informaci\u00f3n sobre la diferencia entre ADD y COPY: https://nickjanetakis.com/blog/docker-tip-2-the-difference-between-copy-and-add-in-a-dockerile Ejemplo de uso de ADD: ADD ./mifichero.zip /var/www/html Descomprimir\u00e1 el contenido de \u201cmifichero.zip\u201d en el directorio destino de la nueva imagen. Ejemplo de uso de COPY: COPY ./mifichero.zip /var/www/html o incluso accediendo desde la web. COPY http://miservidor.commifichero.zip /var/www/html En este caso, copiar\u00e1 el fichero \u201cmifichero.zip\u201d en el directorio destino de la nueva im\u00e1gen. ENTRYPOINT \u00b6 Por defecto, los contenedores Docker est\u00e1n configurados para que ejecuten los comandos que se lancen mediante \u201c/bin/sh -c\u201d. Dicho de otra forma, los comandos que lanz\u00e1bamos, eran par\u00e1metros para \u201c/bin/sh -c\u201d. Podemos cambiar qu\u00e9 comando se usa para esto con ENTRYPOINT. Por ejemplo: ENTRYPOINT [\"cat\"] CMD [\"/etc/passwd\"] Indicaremos que los comandos sean lanzados con \u201ccat\u201d. Al lanzar el comando \u201c/etc/passwd\u201d, realmente lo que haremos es que se lanzar\u00e1 \u201ccat /etc/passwd\u201d. USER \u00b6 Por defecto, todos los comandos lanzados en la creaci\u00f3n de la imagen se ejecutan con el usuario root (usuario con UID=0). Para poder cambiar esto, podemos usar el comando USER, indicando el nombre de usuario o UID con el que queremos que se ejecute el comando. Por ejemplo: USER paco CMD id Mostrar\u00e1 con el comando \u201cid\u201d el uid y otra informaci\u00f3n del usuario paco. WORKDIR \u00b6 Cada vez que expresamos el comando WORKDIR, estamos cambiando el directorio de la imagen donde ejecutamos los comandos. Si este directorio no existe, se crea. Por ejemplo: WORKDIR /root CMD mkdir tmp WORKDIR /var/www/html CMD mkdir tmp Crear\u00e1 la carpeta \u201ctmp\u201d tanto en \u201c/root\u201d como en \u201c/var/www/html\u201d. Si los directorios \u201c/root\u201d o \u201c/var/www/html\u201d no hubieran existido, los hubiera creado. ENV \u00b6 El comando ENV nos permite definir variables de entorno por defecto en la imagen. ENV v1=\u201dvalor1\u201d v2=\u201dvalor2\u201d Esto definir\u00e1 las variables de entorno \u201cv1\u201d y \u201cv2\u201d con los valores \u201cvalor1\u201d y \u201cvalor2\u201d. DockerFile Para una descripci\u00f3n completa sobre el fichero Dockerfile , puedes acceder a la documentaci\u00f3n oficial .","title":"Instrucciones"},{"location":"imagenes/creacion_contenedores/","text":"Si navegas un poco por las distintas im\u00e1genes que encuentras en el registro de Docker Hub, te dar\u00e1s cuenta, que existen tres tipos de im\u00e1genes seg\u00fan la utilidad que nos ofrecen. Ejecutaremos contenedores de distintos sistemas operativos (Ubuntu, CentOs, Debian, Fedora....). Ejecutaremos contenedores que tengan servicios asociados (Apache, MySQL, Tomcat....). Ejecutaremos contenedores que tengan servicios asociados y que tienen instalada alguna aplicaci\u00f3n web (WordPress, Nextcloud,...) Todas las im\u00e1genes tiene definidas un proceso que se ejecuta por defecto, pero en la mayor\u00eda de los casos podemos indicar un proceso al crear un contenedor. Por ejemplo en la imagen ubuntu el proceso pode defecto es bash , por lo tanto podemos ejecutar: $ docker run -it --name contenedor1 ubuntu Pero podemos indicar el comando a ejecutar en la creaci\u00f3n del contenedor: $ docker run ubuntu /bin/echo 'Hello world' Otro ejemplo: la imagen httpd:2.4 ejecuta un servidor web por defecto, por lo tanto al crear el contenedor: $ docker run -d --name my-apache-app -p 8080 :80 httpd:2.4","title":"Creaci\u00f3n de contenedores desde im\u00e1genes"},{"location":"imagenes/creacion_imagenes/","text":"El sistema de im\u00e1genes de Docker funciona como un control de versiones por capas, de forma similar a la herramienta \u201cgit\u201d para control de versiones. Podemos entender que un contenedor es como una \u201ccapa temporal\u201d de una imagen, por lo cual, podemos hacer un \u201ccommit\u201d y convertir esa \u201ccapa temporal\u201d en una imagen. La sintaxis m\u00e1s habitual es la siguiente: docker commit -a \"autor\" -m \"comentario\" ID/NOMBRE-CONTENEDOR usuario/imagen:[version] Por ejemplo, si tenemos un contenedor con nombre \u201cmi_ubuntu\u201d que simplemente es un contenedor basado en la imagen \u201cubuntu\u201d en el que se ha instalado un programa y hacemos: docker commit -a \"paco\" -m \"Ubuntu modificado\" IDCONTENEDOR paco/ubuntumod:22 y tras ello, comprobamos las im\u00e1genes con docker images observamos lo siguiente: paco@paco-xubuntu:~$ sudo docker commit -a \"paco\" -m \"Ubuntu modificado\" mi_ubuntu paco/ubuntumod:22 sha256:cb4889c722bed0a38dcdf3c7a7272b0a26d4ef3e9a4d5c18752601c75204b2fa paco@paco-xubuntu:~$ sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE paco/ubuntumod 22 cb4889c722be 25 seconds ago 123MB ubuntu latest a8780b506fa4 12 days ago 77.8MB Ahora ya podr\u00edamos crear nuevos contenedores con esa imagen, usando por ejemplo: docker run -it paco/ubuntumod:22 Si quisi\u00e9ramos a\u00f1adir una nueva etiqueta a la imagen, como \u201clatest\u201d, podemos usar el comando \u201cdocker tag\u201d, teniendo en cuenta que una misma imagen puede tener varias etiquetas: docker tag paco/ubuntumod:22 paco/ubuntumod:latest Para eliminar una etiqueta, simplemente deberemos borrar la imagen con docker rmi. La imagen se mantendr\u00e1 mientras al menos tenga una etiqueta. Por ejemplo con: docker rmi paco/ubuntumod:22 M\u00e1s informaci\u00f3n de los comandos en: Docker commit https://docs.docker.com/engine/reference/commandline/commit/ Docker tag https://docs.docker.com/engine/reference/commandline/tag/","title":"Creaci\u00f3n de im\u00e1genes desde contenedores"},{"location":"imagenes/creacion_imagenes_dockerfile/","text":"Crear im\u00e1genes con el m\u00e9todo anterior tiene algunos inconvenientes: No se puede reproducir la imagen . Si la perdemos tenemos que recordar toda la secuencia de \u00f3rdenes que hab\u00edamos ejecutado desde que arrancamos el contenedor hasta que ten\u00edamos una versi\u00f3n definitiva e hicimos docker commit . No podemos configurar el proceso que se ejecutar\u00e1 en el contenedor creado desde la imagen . Los contenedores creados a partir de la nueva imagen ejecutaran por defecto el proceso que estaba configurado en la imagen base. No podemos cambiar la imagen de base . Si ha habido alguna actualizaci\u00f3n, problemas de seguridad, etc. con la imagen de base tenemos que descargar la nueva versi\u00f3n, volver a crear un nuevo contenedor basado en ella y ejecutar de nuevo toda la secuencia de \u00f3rdenes. Por todas estas razones, el m\u00e9todo preferido para la creaci\u00f3n de im\u00e1genes es el uso de ficheros Dockerfile y el comando docker build . En el apartado Docker File puedes ver c\u00f3mo realizarlo Con este m\u00e9todo vamos a tener las siguientes ventajas: Podremos reproducir la imagen f\u00e1cilmente ya que en el fichero Dockerfile tenemos todas y cada una de las \u00f3rdenes necesarias para la construcci\u00f3n de la imagen. Si adem\u00e1s ese Dockerfile est\u00e1 guardado en un sistema de control de versiones como git podremos, no s\u00f3lo reproducir la imagen si no asociar los cambios en el Dockerfile a los cambios en las versiones de las im\u00e1genes creadas. Podremos configurar el proceso que se ejecutar\u00e1 por defecto en los contenedores creados a partir de la nueva imagen . Si queremos cambiar la imagen de base esto es extremadamente sencillo con un Dockerfile , \u00fanicamente tendremos que modificar la primera l\u00ednea de ese fichero tal y como explicaremos posteriormente.","title":"Creaci\u00f3n de im\u00e1genes con Dockerfile"},{"location":"imagenes/exportar_importar/","text":"Exportar \u00b6 Si tenemos una imagen local en nuestro sistema, podemos hacer una copia de la misma, ya sea como copia de seguridad o como forma de transportarla a otros sistemas mediante el comando \u201cdocker save\u201d. Por ejemplo se puede hacer de estas dos formas: docker save -o copiaSeguridad.tar paco/ubuntumod o de forma alternativa docker save > paco/ubuntumod copiaSeguridad.tar Importar \u00b6 Si queremos importar el fichero para crear una imagen en nuestra m\u00e1quina, podemos usar docker import . Por ejemplo se puede hacer de estas dos formas: docker load -i copiaSeguridad.tar o de forma alternativa docker load < copiaSeguridad.tar M\u00e1s informaci\u00f3n sobre los comandos: Docker save: https://docs.docker.com/engine/reference/commandline/save/ Docker load: https://docs.docker.com/engine/reference/commandline/load/","title":"Exportar/Importar im\u00e1genes locales"},{"location":"imagenes/gestion/","text":"Para crear un contenedor es necesario usar una imagen que tengamos descargado en nuestro registro local. Por lo tanto al ejecutar docker run se comprueba si tenemos la versi\u00f3n indicada de la imagen y si no es as\u00ed, se precede a su descarga. Las principales instrucciones para trabajar con im\u00e1genes son: docker images : Muestra las im\u00e1genes que tenemos en el registro local. docker pull : Nos permite descargar la \u00faltima versi\u00f3n de la imagen indicada. docker search : Nos permite buscar im\u00e1genes en Docker Hub. docker rmi : Nos permite eliminar im\u00e1genes. No podemos eliminar una im\u00e1gen si tenemos alg\u00fan contenedor creada a partir de ella. docker inspect : nos da informaci\u00f3n sobre la im\u00e1gen indicada: El id y el checksum de la imagen. Los puertos abiertos. La arquitectura y el sistema operativo de la imagen. El tama\u00f1o de la imagen. Los vol\u00famenes. El ENTRYPOINT que es lo que se ejecuta al hacer docker run . Las capas. Y muchas m\u00e1s cosas.... docker history : No permite ver el historial de una imagen descargada, es decir, en qu\u00e9 versiones se basa. Listar im\u00e1genes locales \u00b6 Podemos obtener informaci\u00f3n de qu\u00e9 im\u00e1genes tenemos almacenadas localmente usando: $docker images Obteniendo un resultado similar al siguiente: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest a8780b506fa4 4 days ago 77 .8MB httpd latest fe8735c23ec5 12 days ago 145MB Listar im\u00e1genes para su descarga \u00b6 Podemos obtener informaci\u00f3n de im\u00e1genes que podemos descargar en el registro (Docker Hub) utilizando el comando docker search. Por ejemplo con el siguiente comando: $docker search ubuntu Nos aparecen aquellas im\u00e1genes disponibles en Docker Hub con esa palabra. Descargar im\u00e1genes \u00b6 Podemos almacenar im\u00e1genes localmente desde el registro sin necesidad de crear un contenedor mediante el comando docker pull, claramente inspirado en sistemas de control de versiones como \u201cgit\u201d. $docker pull ubuntu:20.04 Este comando nos descarga la imagen \u201cubuntu\u201d con el tag \u201c20.04\u201d, como vemos a continuaci\u00f3n: $ docker pull ubuntu:20.04 20.04: Pulling from library/ubuntu eaead16dc43b: Pull complete Digest: sha256:450e066588f42ebe1551f3b1a535034b6aa46cd936fe7f2c6b0d72997ec61dbd Status: Downloaded newer image for ubuntu:20.04 docker.io/library/ubuntu:20.04 Eliminar im\u00e1genes con docker rmi \u00b6 Si queremos eliminar im\u00e1genes descargadas que no vamos a utilizar o hemos descargado por error una versi\u00f3n incorrecta, etc., debemos utilizar el comando: $docker rmi ubuntu:20.04 Eliminar todas las im\u00e1genes que no se est\u00e1n utilizando Una forma de eliminar todas las im\u00e1genes locales que no est\u00e9n siendo utilizadas por un contenedor, es combinando docker images -q para obtener la lista y docker rmi para eliminar la lista obtenida. $docker rmi $(docker images -q) Eliminar todas la im\u00e1genes y contenedores \u00b6 Una forma de realizar las operaciones anteriores de golpe, es usando docker system prune -a , que elimina todas las im\u00e1genes y contenedores parados. Paso 1. Paramos todos los contenedores (opcional). $docker stop $(docker ps -a -q) Paso 2. Borramos todos los contenedores. $docker system prune -a","title":"Gesti\u00f3n de Im\u00e1genes"},{"location":"imagenes/mediawiki/","text":"La mediawiki en una aplicaci\u00f3n web escrita en PHP que nos permite gestionar una wiki. En este ejemplo vamos a hacer un ejemplo simple de despliegue en contenedor usando la imagen mediawiki que encontramos en DockerHub. En este ejemplo nos vamos a fijar c\u00f3mo por medio de la etiqueta del nombre de la imagen podemos tener distintas versiones de la aplicaci\u00f3n. En concreto, si estudiamos la documentaci\u00f3n de la imagen mediawiki , podemos ver las etiquetas disponibles para la imagen que corresponden a versiones distintas de la aplicaci\u00f3n. La etiqueta latest \u00b6 Si utilizamos el nombre de una imagen sin indicar la etiqueta, se toma por defecto la etiqueta latest que suele corresponder a la \u00faltima versi\u00f3n de la aplicaci\u00f3n. en el caso concreto de mediawiki observamos que la etiqueta latest corresponde a la \u00faltima versi\u00f3n la 1.37.1 . Es m\u00e1s, podemos usar las siguientes etiquetas para indicar la misma versi\u00f3n: 1.37.1, 1.37, stable, latest . Las im\u00e1genes bases y la arquitectura tambi\u00e9n son indicadas con las etiquetas \u00b6 Podemos seguir observando que algunas etiquetas, nos indican adem\u00e1s de la versi\u00f3n, los servicios que tienen instalada la imagen, por ejemplo si usamos la etiqueta 1.37.1-fpm estaremos creando un contenedor con la ultima versi\u00f3n de la aplicaci\u00f3n pero que adem\u00e1s tendr\u00e1 un servidor de aplicaciones php-fpm para servir la aplicaci\u00f3n. Otro ejemplo: si usamos la etiqueta 1.37.1-fpm-alpine , adem\u00e1s de la \u00faltima versi\u00f3n y que tiene instalado php-fpm, nos indica que la imagen base que se ha usado para crear la imagen es una distribuci\u00f3n alpine que se caracteriza por ser una distribuci\u00f3n muy liviana. Instalaci\u00f3n de distintas versiones de la mediawiki \u00b6 Vamos a crear distintos contenedores usando etiquetas distintas al indicar el nombre de la imagen, posteriormente accederemos a la aplicaci\u00f3n y podremos ver la versi\u00f3n instalada: En primer lugar vamos a instalar la \u00faltima versi\u00f3n: docker run -d -p 8080 :80 --name mediawiki1 mediawiki Si accedemos a la ip de nuestro ordenador, al puerto 8080, podemos observar que hemos instalado la versi\u00f3n 1.37.1: A continuaci\u00f3n vamos a instalar otra versi\u00f3n de la mediawiki, la 1.36.3, creamos otro contenedor con otro nombre y mapeamos otro puerto: docker run -d -p 8081 :80 --name mediawiki2 mediawiki:1.36.3 Si accedemos a la ip de nuestro ordenador, al puerto 8081, podemos observar que hemos instalado la versi\u00f3n 1.36.3: Y finalmente vamos a instalar otra versi\u00f3n en otro contenedor: docker run -d -p 8082 :80 --name mediawiki3 mediawiki:1.35.5 Si accedemos a la ip de nuestro ordenador, al puerto 8082, podemos observar que hemos instalado la versi\u00f3n 1.35.5: Nota: Puedes observar que la primera imagen que se baja, descargas todas las capas, sin embargo al descargar las otras versiones de la imagen, s\u00f3lo se bajan las capas que difieren de la primera.","title":"Ejemplo.- Desplegando la aplicaci\u00f3n mediawiki"},{"location":"imagenes/organizacion/","text":"Las im\u00e1genes est\u00e1n hechas de capas ordenadas . Puedes pensar en una capa como un conjunto de cambios en el sistema de archivos. Cuando tomas todas las capas y las apilas, obtienes una nueva imagen que contiene todos los cambios acumulados. Si tienes muchas im\u00e1genes basadas en capas similares, como Sistema Operativo base o paquetes comunes, entonces todas \u00e9stas capas comunes ser\u00e1 almacenadas solo una vez. Cuando un nuevo contenedor es creado desde una imagen, todas las capas de la imagen son \u00fanicamente de lectura y una delgada capa lectura-escritura es agregada arriba. Todos los cambios efectuados al contenedor espec\u00edfico son almacenados en esa capa. El contenedor no puede modificar los archivos desde su capa de imagen (que es s\u00f3lo lectura). Crear\u00e1 una copia del fichero en su capa superior, y desde ese punto en adelante, cualquiera que trate de acceder al archivo obtendr\u00e1 la copia de la capa superior. Por lo tanto cuando creamos un contenedor ocupa muy poco de disco duro, porque las capas de la imagen desde la que se ha creado se comparten con el contenedor: Veamos el tama\u00f1o de nuestra imagen ubuntu : $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest f63181f19b2f 7 days ago 72 .9MB Si creamos un contenedor interactivo: $ docker run -it --name contenedor1 ubuntu /bin/bash Nos salimos, y a continuaci\u00f3n visualizamos los contenedores con la opci\u00f3n -s (size): $ docker ps -a -s CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZE a2d1ce6990d8 ubuntu \"/bin/bash\" 8 seconds ago Exited ( 130 ) 5 seconds ago contenedor1 0B ( virtual 72 .9MB ) Nos damos cuenta que el tama\u00f1o real del contenedor es 0B y el virtual, el que comparte con la imagen son los 72,9MB que es el tama\u00f1o de la imagen ubuntu. Si a continuaci\u00f3n volvemos a acceder al contenedor y creamos un fichero: $ docker start contenedor1 contenedor1 $ docker attach contenedor1 root@a2d1ce6990d8:/# echo \"00000000000000000\" >file.txt Y volvemos a ver el tama\u00f1o, vemos que ha crecido con la creaci\u00f3n del fichero: $ docker ps -a -s CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZE a2d1ce6990d8 ubuntu \"/bin/bash\" 56 seconds ago Exited ( 0 ) 2 seconds ago contenedor1 52B ( virtual 72 .9MB ) Por todo lo que hemos explicado, ahora se entiende que no podemos eliminar una im\u00e1gen cuando tenemos contenedores creados a a partir de ella . Por \u00faltimo al solicitar informaci\u00f3n de la im\u00e1gen, podemos ver informaci\u00f3n sobre las capas: $ docker inspect ubuntu:latest ... \"RootFS\" : { \"Type\" : \"layers\" , \"Layers\" : [ \"sha256:9f32931c9d28f10104a8eb1330954ba90e76d92b02c5256521ba864feec14009\" , \"sha256:dbf2c0f42a39b60301f6d3936f7f8adb59bb97d31ec11cc4a049ce81155fef89\" , \"sha256:02473afd360bd5391fa51b6e7849ce88732ae29f50f3630c3551f528eba66d1e\" ] ...","title":"\u00bfC\u00f3mo se organizan las im\u00e1genes?"},{"location":"imagenes/registro/","text":"El Registro docker es un componente donde se almacena las im\u00e1genes generadas por el Docker Engine. Puede estar instalada en un servidor independiente y es un componente fundamental, ya que nos permite distribuir nuestras aplicaciones. Es un proyecto open source que puede ser instalado gratuitamente en cualquier servidor, pero, como hemos comentado, el proyecto nos ofrece Docker Hub. El nombre de una imagen suele estar formado por tres partes: usuario/nombre:etiqueta usuario : El nombre del usuario que la ha generado. Si la subimos a Docker Hub debe ser el mismo usuario que tenemos dado de alta en nuestra cuenta. Las im\u00e1ges oficiales en Docker Hub no tienen nombre de usuario. nombre : Nombre significativo de la imagen. etiqueta : Nos permite versionar las im\u00e1genes. De esta manera controlamos los cambios que se van produciendo en ella. Si no indicamos etiqueta, por defecto se usa la etiqueta latest , por lo que la mayor\u00eda de las im\u00e1genes tienen una versi\u00f3n con este nombre.","title":"Registro de Im\u00e1genes.- DockerHub"},{"location":"imagenes/subir_imagen_dockerhub/","text":"Podemos subir una im\u00e1gen a un repositorio (por defecto Docker Hub). Para ello, primero debemos crearnos una cuenta en Docker Hub . Una vez creada la cuenta y no hayamos logueado, debemos acceder a Repositories y en Create repository como se ve en la imagen: A continuaci\u00f3n, crearemos un repositorio y eligiremos si nuestro repositorio es p\u00fablico (cualquiera puede acceder) o privado (s\u00f3lo puede acceder el due\u00f1o o autorizados). La pantalla de creaci\u00f3n del repositorio es la siguiente: Una vez tenganos el repositorio creado tenemos que logearnos a nuestra cuenta a trav\u00e9s de la consola de nuestro equipo mediante el comando: docker login Una vez logueado, debemos hacer un \u201ccommit\u201d local de la imagen, siguiendo la estructura vista en el punto anterior. Un ejemplo podr\u00eda ser: docker commit -a \"paco\" -m \"Apache con nano\" IDCONTENEDOR framafra/apachenano:latest donde, framafra es el nombre de usuario de la cuenta de Docker Hub apachenano es el nombre de la imagen latest es la etiqueta de la imagen Y por \u00faltimo, para subirlo este commit local, debemos subirlo usando \u201cdocker push\u201d docker push framafra/apachenano Una vez hecho eso, si la imagen es p\u00fablica, cualquiera podr\u00e1 descargarla y crear contenedores usando \u201cdocker pull\u201d o \u201cdocker run\u201d. M\u00e1s informaci\u00f3n de los comandos: Docker login https://docs.docker.com/engine/reference/commandline/login/ Docker push https://docs.docker.com/engine/reference/commandline/push/","title":"Subir im\u00e1genes a Docker Hub"},{"location":"primeros_pasos/hello/","text":"El \"Hola Mundo\" de docker \u00b6 Vamos a comprobar que todo funciona creando nuestro primer contenedor desde la imagen hello-world : $ docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 0e03bdcc26d7: Pull complete Digest: sha256:31b9c7d48790f0d8c50ab433d9c3b7e17666d6993084c002c2ff1ca09b96391d Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1 . The Docker client contacted the Docker daemon. 2 . The Docker daemon pulled the \"hello-world\" image from the Docker Hub. ( amd64 ) 3 . The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4 . The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Pero, \u00bfqu\u00e9 es lo que est\u00e1 sucediendo al ejecutar esa orden?: Si nos fijamos en el comienzo de la informaci\u00f3n mostrada, concretamente en la primera fila ( Unable to find image 'hello-world:latest' locally ), ah\u00ed se nos indica que la imagen hello-word:latest no est\u00e1 localmente en nuestro sistema. Al no estar, la imagen hello-word se descarga desde el repositorio que se encuentra en el registro que vayamos a utilizar, en nuestro caso DockerHub. De hecho, si volvemos a hacer el comando \u201cdocker run hello-world\u201d, al tener la imagen ya en el sistema, no nos aparecer\u00e1 este texto, ya que la imagen la tenemos almacenada localmente. Otro aspecto a destacar, es que pese a que solo hemos escrito hello-world, nos ha descargado una imagen llamada hello-world:latest. Esto es porque cada imagen creada tiene un nombre de versi\u00f3n. Si no indicamos nada o indicamos latest, nos instala la \u00faltima versi\u00f3n. Si queremos instalar una versi\u00f3n concreta de una imagen se indica de la forma imagen:nombreversion. Y por \u00faltimo podemos observar que muestra el mensaje de bienvenida que es la consecuencia de ejecutar un comando al crear y arrancar un contenedor basado en esa imagen. Si listamos los contenedores que se est\u00e1n ejecutando ( docker ps ): $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Comprobamos que este contenedor no se est\u00e1 ejecutando. Un contenedor ejecuta un proceso y cuando termina la ejecuci\u00f3n, el contenedor se para. Para ver los contenedores que no se est\u00e1n ejecutando: $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 372ca4634d53 hello-world \"/hello\" 8 minutes ago Exited ( 0 ) 8 minutes ago elastic_johnson Para eliminar el contenedor podemos identificarlo con su id : $ docker rm 372ca4634d53 o con su nombre: $ docker rm elastic_johnson Buscar imagenes Para buscar las im\u00e1genes de cualquier sistema, utilizaremos la orden: $docker search NombreImagen El script rastrear\u00e1 Docker Hub y nos ofrecer\u00e1 una lista de todas las im\u00e1genes que tengan un nombre que concuerde con la b\u00fasqueda lanzada. Descargar imagenes Para descargar la imagen que queremos, utilizaremos la orden: $docker pull NombreImagen Despu\u00e9s de descargar una imagen, se puede ejecutar un contenedor utilizando la imagen descargada con el comando run. Si no se ha descargado la imagen previamente, autom\u00e1ticamente Docker primero descargar\u00e1 la imagen y despu\u00e9s ejecutar\u00e1 un contenedor con la imagen descargada. Ver las imagenes descargadas Para ver las im\u00e1genes que tenemos descargadas, utilizaremos la orden: $docker images","title":"Hello World de Docker"},{"location":"primeros_pasos/hello/#el-hola-mundo-de-docker","text":"Vamos a comprobar que todo funciona creando nuestro primer contenedor desde la imagen hello-world : $ docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 0e03bdcc26d7: Pull complete Digest: sha256:31b9c7d48790f0d8c50ab433d9c3b7e17666d6993084c002c2ff1ca09b96391d Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1 . The Docker client contacted the Docker daemon. 2 . The Docker daemon pulled the \"hello-world\" image from the Docker Hub. ( amd64 ) 3 . The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4 . The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Pero, \u00bfqu\u00e9 es lo que est\u00e1 sucediendo al ejecutar esa orden?: Si nos fijamos en el comienzo de la informaci\u00f3n mostrada, concretamente en la primera fila ( Unable to find image 'hello-world:latest' locally ), ah\u00ed se nos indica que la imagen hello-word:latest no est\u00e1 localmente en nuestro sistema. Al no estar, la imagen hello-word se descarga desde el repositorio que se encuentra en el registro que vayamos a utilizar, en nuestro caso DockerHub. De hecho, si volvemos a hacer el comando \u201cdocker run hello-world\u201d, al tener la imagen ya en el sistema, no nos aparecer\u00e1 este texto, ya que la imagen la tenemos almacenada localmente. Otro aspecto a destacar, es que pese a que solo hemos escrito hello-world, nos ha descargado una imagen llamada hello-world:latest. Esto es porque cada imagen creada tiene un nombre de versi\u00f3n. Si no indicamos nada o indicamos latest, nos instala la \u00faltima versi\u00f3n. Si queremos instalar una versi\u00f3n concreta de una imagen se indica de la forma imagen:nombreversion. Y por \u00faltimo podemos observar que muestra el mensaje de bienvenida que es la consecuencia de ejecutar un comando al crear y arrancar un contenedor basado en esa imagen. Si listamos los contenedores que se est\u00e1n ejecutando ( docker ps ): $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Comprobamos que este contenedor no se est\u00e1 ejecutando. Un contenedor ejecuta un proceso y cuando termina la ejecuci\u00f3n, el contenedor se para. Para ver los contenedores que no se est\u00e1n ejecutando: $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 372ca4634d53 hello-world \"/hello\" 8 minutes ago Exited ( 0 ) 8 minutes ago elastic_johnson Para eliminar el contenedor podemos identificarlo con su id : $ docker rm 372ca4634d53 o con su nombre: $ docker rm elastic_johnson Buscar imagenes Para buscar las im\u00e1genes de cualquier sistema, utilizaremos la orden: $docker search NombreImagen El script rastrear\u00e1 Docker Hub y nos ofrecer\u00e1 una lista de todas las im\u00e1genes que tengan un nombre que concuerde con la b\u00fasqueda lanzada. Descargar imagenes Para descargar la imagen que queremos, utilizaremos la orden: $docker pull NombreImagen Despu\u00e9s de descargar una imagen, se puede ejecutar un contenedor utilizando la imagen descargada con el comando run. Si no se ha descargado la imagen previamente, autom\u00e1ticamente Docker primero descargar\u00e1 la imagen y despu\u00e9s ejecutar\u00e1 un contenedor con la imagen descargada. Ver las imagenes descargadas Para ver las im\u00e1genes que tenemos descargadas, utilizaremos la orden: $docker images","title":"El \"Hola Mundo\" de docker"},{"location":"primeros_pasos/instalacion/","text":"Instalaci\u00f3n de docker \u00b6 Existe dos versiones de Docker, una libre y otra que no lo es. Nos ocuparemos exclusivamente de la primera: Docker CE (Community Edition) . Docker CE est\u00e1 disponible para los siguientes sistemas GNU/Linux: CentOS, Debian, Fedora y Ubuntu. No todas est\u00e1n en m\u00faltiples arquitecturas, pero s\u00ed todas soportan x86_64/amd64 . Si tienes otra arquitectura u otro sistema es mejor que uses una m\u00e1quina virtual para arrancar una distribuci\u00f3n compatible. Para m\u00e1s informaci\u00f3n sobre sistemas privativos soportados, leer la secci\u00f3n de plataformas soportadas de la documentaci\u00f3n oficial. Instalaci\u00f3n \u00b6 Debido a que, dependiendo de la distribuci\u00f3n, la forma de instalarlo difiere, es mejor consultar la documentaci\u00f3n oficial para saber como instalar Docker en tu m\u00e1quina. Ubuntu: https://docs.docker.com/install/linux/docker-ce/ubuntu/ Debian: https://docs.docker.com/install/linux/docker-ce/debian/ CentOS: https://docs.docker.com/install/linux/docker-ce/centos/ Fedora: https://docs.docker.com/install/linux/docker-ce/fedora/ Note Es posible instalar Docker engine desde el repositorio oficial de Ubuntu, pero no est\u00e1 recomendado ya que instala versiones antiguas. Es recomendable desinstalar las versiones antiguas antes de realizar la instalaci\u00f3n y as\u00ed evitar que pudiesen haber conflictos. En sistemas Ubuntu, para eliminar las versiones antiguas, podemos ejecutar la instrucci\u00f3n: sudo apt-get remove docker docker-engine docker.io containerd runc Comprobar la versi\u00f3n instalada. sudo docker version Configuraci\u00f3n del usuario \u00b6 Si estamos usando Docker en nuestro ordenador personal, podemos configurar nuestro usuario para usar el cliente sin tener que poner sudo delante. Para ello ejecuta lo siguiente: sudo usermod -aG docker $USER Para que los nuevos permisos surtan efecto, debes cerrar y volver a abrir la sesi\u00f3n. Para problemas relacionados con los permisos visitad la p\u00e1gina del manual oficial . Activar/desactivar arranque al inicio \u00b6 Para indicar que el servicio Docker se inicie al arrancar la m\u00e1quina, podemos indicarlo mediante los siguientes comandos: sudo systemctl enable docker.service sudo systemctl enable containerd.service Si lo que queremos es deshabilitar este arranque autom\u00e1tico, podemos usar: sudo systemctl disable docker.service sudo systemctl disable containerd.service Para iniciar/parar/reiniciar los servicios manualmente, podemos usar: sudo systemctl start/stop/restart docker.service sudo systemctl start/stop/restart containerd.service","title":"Instalaci\u00f3n"},{"location":"primeros_pasos/instalacion/#instalacion-de-docker","text":"Existe dos versiones de Docker, una libre y otra que no lo es. Nos ocuparemos exclusivamente de la primera: Docker CE (Community Edition) . Docker CE est\u00e1 disponible para los siguientes sistemas GNU/Linux: CentOS, Debian, Fedora y Ubuntu. No todas est\u00e1n en m\u00faltiples arquitecturas, pero s\u00ed todas soportan x86_64/amd64 . Si tienes otra arquitectura u otro sistema es mejor que uses una m\u00e1quina virtual para arrancar una distribuci\u00f3n compatible. Para m\u00e1s informaci\u00f3n sobre sistemas privativos soportados, leer la secci\u00f3n de plataformas soportadas de la documentaci\u00f3n oficial.","title":"Instalaci\u00f3n de docker"},{"location":"primeros_pasos/usobasico/","text":"Usar Docker consiste en pasar una cadena de opciones y comandos seguidos de argumentos, la sintaxis ser\u00eda la siguiente: $docker [option] [command] [arguments] Para ver todos los subcomandos disponibles podemos ejecutar: $docker Si queremos sabe que realiza un comando en concreto, tendremos que ejecutar: $docker docker -subcommand --help \u201cdocker -subcommand\u201d puede ser cualquiera de los mostrados por $docker. Como hemos visto anteriormente los contenedores Docker se forman a partir de im\u00e1genes de Docker. Por defecto, Docker extrae estas im\u00e1genes de Docker Hub , recordemos que es un registro de Docker administrado por Docker, la empresa responsable del proyecto Docker. Cualquier persona es capaz de guardar sus im\u00e1genes Docker en Docker Hub, por lo tanto, la mayor\u00eda de aplicaciones y distribuciones Linux que necesitaremos tendr\u00e1n las im\u00e1genes guardadas.","title":"Uso B\u00e1sico"},{"location":"redes/redes/","text":"Tipos de redes en Docker \u00b6 Cuando instalamos docker tenemos las siguientes redes predefinidas: $ docker network ls NETWORK ID NAME DRIVER SCOPE ec77cfd20583 bridge bridge local 69bb21378df5 host host local 089cc966eaeb none null local Red Bridge \u00b6 Por defecto los contenedores que creamos se conectan a la red de tipo bridge llamada bridge (por defecto el direccionamiento de esta red es 172.17.0.0/16). Los contenedores conectados a esta red que quieren exponer alg\u00fan puerto al exterior tienen que usar la opci\u00f3n -p para mapear puertos. Este tipo de red nos van a permitir: Aislar los distintos contenedores que tengo en distintas subredes docker, de tal manera que desde cada una de las subredes solo podremos acceder a los equipos de esa misma subred. Aislar los contenedores del acceso exterior. Publicar servicios que tengamos en los contenedores mediante redirecciones que docker implementar\u00e1 con las pertinentes reglas de iptables. Veamos un ejemplo: Vamos a crear un contenedor interactivos con la imagen debian : $ docker run -it --name contenedor1 --rm debian bash Nota: Hemos usado la opci\u00f3n --rm para al finalizar de ejecutar el proceso, el contenedor se elimina. En otra pesta\u00f1a , podemos ejecutar esta instrucci\u00f3n para obtener la ip que se le ha asignado: $ docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' contenedor1 172.17.0.2 Obtenemos informaci\u00f3n del contenedor filtrando el json de salida para obtener la IPv4 que se le ha asignado. Observamos que el contenedor tiene una ip en la red 172.17.0.0/16 . Adem\u00e1s, con el comando ip a o ip a show docker0 podemos comprobar que se ha creado un bridge en el host, al que se conectan los contenedores: $ ip a ... 5 : docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default link/ether 02 :42:be:71:11:9e brd ff:ff:ff:ff:ff:ff inet 172 .17.0.1/16 brd 172 .17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:beff:fe71:119e/64 scope link valid_lft forever preferred_lft forever ... Adem\u00e1s podemos comprobar que se han creado distintas cadenas en el cortafuegos para gestionar la comunicaci\u00f3n de los contenedores. Podemos ejecutar como administrador: iptables -L -n y iptables -L -n - t nat y comprobarlo. Red Host \u00b6 Si conecto un contenedor a la red host , el contenedor ofrece el servicio que tiene configurado en el puerto de la red del anfitri\u00f3n. No tiene ip propia, sino es c\u00f3mo si tuviera la ip del anfitri\u00f3n. Por lo tanto, los puertos son accesibles directamente desde el host. Por ejemplo: $ docker run -d --name mi_servidor --network host josedom24/aplicacionweb:v1 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 135c742af1ff josedom24/aplicacionweb:v1 \"/usr/sbin/apache2ct\u2026\" 3 seconds ago Up 2 seconds mi_servidor Prueba acceder directamente al puerto 80 del servidor para ver la p\u00e1gina web. Red None \u00b6 La red none no configurar\u00e1 ninguna IP para el contenedor y no tiene acceso a la red externa ni a otros contenedores. Tiene la direcci\u00f3n loopback y se puede usar para ejecutar trabajos por lotes. Paco","title":"Redes"},{"location":"redes/redes_usuario/","text":"Tenemos que hacer una diferenciaci\u00f3n entre dos tipos de redes bridge : La red creada por defecto por docker para que funcionen todos los contenedores. Y las redes \"bridge\" definidas por el usuario. Esta red \"bridge\" por defecto, que es la usada por defecto por los contenedores, se diferencia en varios aspectos de las redes \"bridge\" que creamos nosotros. Estos aspectos son los siguientes: Las redes que nosotros definamos proporcionan resoluci\u00f3n DNS entre los contenedores. Puedo conectar en caliente a los contenedores redes \"bridge\" definidas por el usuario. Al usar redes definidas por el usuario obtengo m\u00e1s aislamiento y control , ya que los contenedores necesarios de una aplicaci\u00f3n no comparten la red con otros contenedores. En definitiva: Es importante que nuestro contenedores en producci\u00f3n se est\u00e9n ejecutando sobre una red definida por el usuario. Para gestionar las redes creadas por el usuario: docker network ls : Listado de las redes. docker network create : Creaci\u00f3n de redes. Ejemplos: docker network create red1 docker network create -d bridge --subnet 172.24.0.0/16 --gateway 172.24.0.1 red2 docker network rm/prune : Borrar redes. Teniendo en cuenta que no puedo borrar una red que tenga contenedores que la est\u00e9n usando. deber\u00e9 primero borrar los contenedores o desconectar la red. docker network inspect : Nos da informaci\u00f3n de la red. Nota: Cada red docker que creo crea un puente de red espec\u00edfico para cada red que podemos ver con ip a : Uso de las redes bridge definidas por el usuario \u00b6 Vamos a crear una red tipo bridge definida por el usuario con la instrucci\u00f3n docker network create : $ docker network create red1 Como no hemos indicado ninguna configuraci\u00f3n en la red que hemos creado, docker asigna un direccionamiento a la red: $ docker network inspect red1 [ { \"Name\" : \"red1\" , ... \"Config\" : [ { \"Subnet\" : \"172.18.0.0/16\" , \"Gateway\" : \"172.18.0.1\" } ] } , ... ] En este caso, hemos creado una red simple con los par\u00e1metros por defecto. Algunos de los par\u00e1metros configurables m\u00e1s interesantes son: \u201c--internal\u201d: para red interna. Restringe el acceso desde el exterior. \u201c--gateway\u201d: para indicar la puerta de enlace de la red. \u201c--ip-range\u201d: delimita el rango de IPs asignables al contenedor. \u201c--ipv6\u201d: habilita el uso de IPV6. \u201c--subnet\u201d: define la subred en formato CIDR. Para m\u00e1s informaci\u00f3n relacionada con el comando \u201cdocker network create\u201d se puede consultar el siguiente enlace: https://docs.docker.com/engine/reference/commandline/network_create/ Comprobaci\u00f3n de la resoluci\u00f3n de nombres entre contendedores \u00b6 Creamos un contenedor y lo conectamos a la red que acabamos de crear: $ docker run -d --name my-apache-app --network red1 -p 8080 :80 httpd:2.4 Creamos otro contenedor y comprobamos la resoluci\u00f3n DNS: $ docker run -it --name contenedor1 --network red1 debian bash root@98ab5a0c2f0c:/# apt update && apt install dnsutils -y ... root@98ab5a0c2f0c:/# dig my-apache-app ... ;; ANSWER SECTION: my-apache-app. 600 IN A 172 .18.0.2 ... ;; SERVER: 127 .0.0.11#53 ( 127 .0.0.11 ) ... Podemos comprobar la configuraci\u00f3n DNS del contenedor: root@98ab5a0c2f0c:/# cat /etc/resolv.conf nameserver 127 .0.0.11 ... Evidentemente desde los dos contenedores se pueden resolver los dos nombres: root@98ab5a0c2f0c:/# dig contenedor1 ... ;; ANSWER SECTION: contenedor1. 600 IN A 172 .18.0.3 ... ;; SERVER: 127 .0.0.11#53 ( 127 .0.0.11 ) ... M\u00e1s opciones al trabajar con redes en docker \u00b6 Podemos conectar \"en caliente\" un contenedor a una nueva red con: docker network connect <red> <contenedor> Para desconectarla de una red podemos usar: docker network disconnect <red> <contenedor> . Tanto al crear un contenedor con el flag --network , como con la instrucci\u00f3n docker network connect , podemos usar algunos otros flags: --dns : para establecer unos servidores DNS predeterminados. --ip : Para establecer una ip fija en el contenedor. --ip6 : para establecer la direcci\u00f3n de red ipv6 --hostname o -h : para establecer el nombre de host del contenedor. Si no lo establezco ser\u00e1 el ID del mismo. --add-host : a\u00f1ade entradas de nuevos hosts en el fichero /etc/hosts Para m\u00e1s informaci\u00f3n sobre las redes: Networking overview .","title":"Redes Definidas por el Usuario"}]}